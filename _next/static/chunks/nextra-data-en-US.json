{"/FAQ":{"title":"FAQ","data":{"why-dont-you-provide-a-ready-to-use-datatable-component#Why don’t you provide a ready to use DataTable component?":"This is actually a feature! We want to give you the freedom of how you want to\ngenerate the cell matrix and how you want to react to data changes.\nFeel free to use our tutorial example to implement your own DataTable component.","why-rows-property-contains-an-array-of-cells#Why rows property contains an array of cells?":"Our experience also shows that it does not matter even when:\nit is the column property that would contain the cell array instead of rows\ncells would be in a one-dimensional array\nRows property contains an array of cells because it conforms to the previously known models in the form of columns and rows.","is-row-resize-implemented-yet#Is row resize implemented yet?":"At this moment it isn't possible, the only way to change row height is by defining its height,\nsee the Row interface.","how-to-identify-the-clicked-cell#How to identify the clicked cell?":"ReactGrid has an onFocusLocationChanging callback function. This function is called every time the focus tries to change\nits location. This callback provides location (CellLocation) parameter.","is-it-possible-to-identify-a-cell-using-a-unique-id#Is it possible to identify a cell using a unique ID?":"Of course, it's possible, but our approach is different from what you probably see in other products.\nHere we don't use commands like: getCell({column: 'A', row: 6}).setValue(0).\nOur task is to display a given cell-matrix and notify about changes. Then you are able to process this change or ignore it.","what-alternatives-do-i-have#What alternatives do I have?":"There are plenty of nice products out there which also integrate well with React.\nHere a short and certainly incomplete list in no particular order:\nagGrid\nHandsontable\nKendo UI (DataGrid or Spreadsheet)\nDevExtreme\nBryntum\ndhtmlxSpreadsheet"}},"/blog":{"title":"Blog","data":{"":"ReactGrid lets you create custom data grids inside your ReactJS applications, which look and feel like spreadsheets."}},"/docs":{"title":"Introduction","data":{"":"ReactGrid lets you create custom data grids inside your ReactJS applications, which look and feel like spreadsheets."}},"/docs/3.0":{"title":"3.0","data":{"":"ReactGrid lets you create custom data grids inside your ReactJS applications, which look and feel like spreadsheets.","about-mit-and-pro-version#About MIT and PRO version":"ReactGrid in both version uses the same component interface. However, if you implement a PRO feature (using MIT package)\nprobably nothing will happen.A functionality that is partly or fully supported by PRO version is marked by  icon.","supported-browsers#Supported browsers":"Desktop Browsers\nMobile Browsers"}},"/docs/3.0/1-getting-started":{"title":"Getting started","data":{"introduction#Introduction":"In this guide, we're going to build a very simple React App, which will make use of ReactGrid.","initialize-a-react-app-with-reactgrid#Initialize a React App with ReactGrid":"Let's create the basis for our App first:\nnpx create-react-app reactgrid-getting-started --typescript\ncd reactgrid-getting-started\nThe only thing that's missing from our project now is ReactGrid itself.\nTo add it to the dependencies, simply run:\nnpm install @silevis/reactgrid","integrate-reactgrid-into-the-app#Integrate ReactGrid into the App":"Once ReactGrid is installed and ready, we can import it in the following way:\n// App.js\nimport * as React from \"react\";\nimport { render } from \"react-dom\";\nimport { ReactGrid, Column, Row } from \"@silevis/reactgrid\";\nimport \"@silevis/reactgrid/styles.css\";\nimport \"./styles.css\";\nOur app requires also ReactGrid component from @silevis/reactgrid and CSS styles from @silevis/reactgrid/styles.css.","define-some-data-to-display-in-the-grid#Define some data to display in the grid":"Although we were able to create an empty ReactGrid, it arguably wouldn't make much sense.\nSo let's define some data first, and then feed it into ReactGrid for display.\nWe're going to need two arrays. One for columns, and the other for rows.\nDon't worry about all of the properties of column and row objects now - we'll cover them later on.\nconst columns = [\n  { columnId: \"Name\", width: 100 },\n  { columnId: \"Surname\", width: 100 }\n];\nconst rows = [\n  {\n    rowId: 0,\n    cells: [\n      { type: \"header\", text: \"Name\" },\n      { type: \"header\", text: \"Surname\" },\n    ],\n  },\n  {\n    rowId: 1,\n    cells: [\n      { type: \"text\", text: \"Thomas\" },\n      { type: \"text\", text: \"Goldman\" },\n    ],\n  },\n  {\n    rowId: 2,\n    cells: [\n      { type: \"text\", text: \"Susie\" },\n      { type: \"text\", text: \"Spencer\" },\n    ],\n  },\n  {\n    rowId: 3,\n    cells: [\n      { type: \"text\", text: \"\" },\n      { type: \"text\", text: \"\" },\n    ],\n  }\n];","pass-the-data-to-reactgrid#Pass the data to ReactGrid":"We've got everything we need to see ReactGrid in action.\nIt's finally time to use the ReactGrid component we imported earlier, and give it the data\nwe defined in the previous step. This is easy, and can be done like that:\n<ReactGrid\n  rows={rows}\n  columns={columns}\n/>","introduce-data#Introduce data":"The data we've defined so far is static. There's nothing wrong with that for the tutorial purposes,\nbut in a real application you'll probably wantb to be able to handle dynamic data updates.\nLet's wrap our rows and columns inside hooks, so that we can easily update them in the future:\nfunction App() {\n  const [columns] = React.useState<Column[]>(() => [\n    { columnId: \"Name\", width: 100 },\n    { columnId: \"Surname\", width: 100 }\n  ]);\n  const [rows] = React.useState<Row[]>(() => [\n    {\n      rowId: 0,\n      cells: [\n        { type: \"header\", text: \"Name\" },\n        { type: \"header\", text: \"Surname\" }\n      ]\n    },\n    {\n      rowId: 1,\n      cells: [\n        { type: \"text\", text: \"Thomas\" },\n        { type: \"text\", text: \"Goldman\" }\n      ]\n    },\n    {\n      rowId: 2,\n      cells: [\n        { type: \"text\", text: \"Susie\" },\n        { type: \"text\", text: \"Spencer\" }\n      ]\n    },\n    {\n      rowId: 3,\n      cells: [\n        { type: \"text\", text: \"\" },\n        { type: \"text\", text: \"\" }\n      ]\n    }\n  ]);\n  // [...]\n}","putting-it-all-together#Putting it all together":"After having followed this guide, your App.js file should look more or less like this:\nimport * as React from \"react\";\nimport { render } from \"react-dom\";\nimport { ReactGrid, Column, Row } from \"@silevis/reactgrid\";\nimport \"@silevis/reactgrid/styles.css\";\nimport \"./styles.css\";\nfunction App() {\n  const [columns] = React.useState<Column[]>(() => [\n    { columnId: \"Name\", width: 100 },\n    { columnId: \"Surname\", width: 100 }\n  ]);\n  const [rows] = React.useState<Row[]>(() => [\n    {\n      rowId: 0,\n      cells: [\n        { type: \"header\", text: \"Name\" },\n        { type: \"header\", text: \"Surname\" }\n      ]\n    },\n    {\n      rowId: 1,\n      cells: [\n        { type: \"text\", text: \"Thomas\" },\n        { type: \"text\", text: \"Goldman\" }\n      ]\n    },\n    {\n      rowId: 2,\n      cells: [\n        { type: \"text\", text: \"Susie\" },\n        { type: \"text\", text: \"Spencer\" }\n      ]\n    },\n    {\n      rowId: 3,\n      cells: [\n        { type: \"text\", text: \"\" },\n        { type: \"text\", text: \"\" }\n      ]\n    }\n  ]);\n  return (\n    <ReactGrid\n      rows={rows}\n      columns={columns}\n    />\n  );\n}\nexport default App;\nYou can now start the App locally with:\nnpm start\nOr simply play around with the interactive demo below:","summary#Summary":"You should now have a basic understanding of what ReactGrid is and how it can be used.\nContinue to the next page for more advanced usage examples."}},"/docs/3.0/2-implementing-core-features":{"title":"Implementing core features","data":{"":"In this section you will learn about common features of ReactGrid and their example implementations.\nHandling data changes\nColumn resizing\nColumn and row reordering\nSticky rows and columns\nSelections\nFill handle\nContext menu\nGroup Id\nHighlights\nGrouping\nManaging focus\nEmbedding on website\nKeyboard shortcuts\nFull width header"}},"/docs/3.0/2-implementing-core-features/1-handling-changes":{"title":"Handling data changes","data":{"idea-of-handling-data-changes#Idea of handling data changes":"A user changes the value of a cell. Among others, it could mean that the user has:\ntyped a new value into a cell by cell editor,\nused a fill handle ,\npasted some data into the cell matrix,\ninteracted with a clickable cell (e. g. expanded group cell).\nReactGrid fires the onCellsChanged event\nYour handler function processes the event and updates the application state\nThe ReactGrid component receives new data and gets rerendered\nBy default, the data grid will behave as if it was in a \"read-only\" mode.\nTo support dynamic data editing, you will have to handle the onCellsChanged event yourself.","when-my-handler-function-is-called#When my handler function is called?":"Changes have been committed after cell editing.\nAfter pasting with the shortcut or the context menu.\nAfter fill handle action.","sample-change-handler-function#Sample change handler function":"We can declare a basic handler function like this:\nconst handleChanges = (changes: CellChange[]) => {\n  setRows((prevRows) => {\n      changes.forEach(change => {\n          const changeRowIdx = prevRows.findIndex(el => el.rowId === change.rowId);\n          const changeColumnIdx = columns.findIndex(el => el.columnId === change.columnId);\n          prevRows[changeRowIdx].cells[changeColumnIdx] = change.newCell;\n      });\n      return [...prevRows];\n  });\n};\nThe function receives an array describing all of the changes made to the data grid's cells.\nGiven that information, we find the row and the column affected by each change,\nand then replace an appropriate cell object with a new one.Let's pass the handler function to our ReactGrid component:\nreturn (\n  <ReactGrid\n    rows={rows}\n    columns={columns}\n    onCellsChanged={handleChanges} // highlight-line\n  />\n)","live-demo#Live demo":"And here's an interactive demo showing the event handler in action.\nNotice how it is now possible to edit the data not only by typing new values into the cells,\nbut also by using the fill handle (only PRO) or by pasting data from the clipboard."}},"/docs/3.0/2-implementing-core-features/2-column-resizing":{"title":"Column resizing","data":{"":"This feature is only available in PRO version","allow-column-to-be-resized#Allow column to be resized":"For each column which should be resizable, add the resizable property\nto the corresponding column object and set its value to true.\nconst [columns, setColumns] = React.useState<Column[]>(() => [\n  { columnId: \"Name\", width: 100, resizable: true }, //highlight-line\n  { columnId: \"Surname\", width: 100, resizable: true } //highlight-line\n]);\nIf you hover over the vertical border line between the column headers,\nyou will see your mouse pointer change to indicate that a column can be resized.\nHowever, you'll quickly notice that the column resizing functionality doesn't work.\nWhy is that? We still need to handle the events fired by ReactGrid when a column is being resized.\nSimilar to how we handled data changes in Handling data changes,\nwe can also define a handler function for that and pass it to our ReactGrid component.","implement-the-event-handler-function#Implement the event handler function":"const handleColumnResize = (ci: Id, width: number) => {\n  setColumns((prevColumns) => {\n    const columnIndex = prevColumns.findIndex(el => el.columnId === ci);\n    const resizedColumn = prevColumns[columnIndex];\n    const updatedColumn = { ...resizedColumn, width };\n    prevColumns[columnIndex] = updatedColumn;\n    return [...prevColumns];\n  });\n}","pass-the-handler-function#Pass the handler function":"return (\n  <ReactGrid\n    rows={rows}\n    columns={columns}\n    onColumnResized={handleColumnResize} //highlight-line\n  />\n);","live-demo#Live demo":"Let's check the results:"}},"/docs/3.0/2-implementing-core-features/3-column-and-row-reordering":{"title":"Column and row reordering","data":{"how-to-implement-column-and-row-reordering#How to implement column and row reordering?":"This feature is only available in PRO version\nThis guide is based on getting started.","1-add-some-new-imports-for-further-usage#1. Add some new imports for further usage":"We'll need Id, DropPosition,\nColumn and Row.\nimport { ReactGrid, Id, DropPosition, Column, Row } from \"@silevis/reactgrid\";  //highlight-line","2-modify-the-rows-and-columns-to-enable-reordering#2. Modify the rows and columns to enable reordering":"This is done by adding the reorderable property to a column or row and setting its value to true.\nconst [columns, setColumns] = React.useState<Column[]>(() => [\n  { columnId: \"Name\", width: 100, reorderable: true },  //highlight-line\n  { columnId: \"Surname\", width: 100, reorderable: true }  //highlight-line\n]);\nNotice that we don't want the first row to be reorderable because that's our grid's header so the reorderable\nproperty will become undefined contrary to other rows.\nconst [rows, setRows] = React.useState<Row[]>(() => [\n  {\n    rowId: 0,\n    reorderable: true, //highlight-line\n    cells: [\n      { type: \"header\", text: \"Name\" },\n      { type: \"header\", text: \"Surname\" }\n    ]\n  },\n  {\n    rowId: 1,\n    reorderable: true, //highlight-line\n    cells: [\n      { type: \"text\", text: \"Thomas\" },\n      { type: \"text\", text: \"Goldman\" }\n    ]\n  },\n  {\n    rowId: 2,\n    reorderable: true, //highlight-line\n    cells: [\n      { type: \"text\", text: \"Susie\" },\n      { type: \"text\", text: \"Spencer\" }\n    ]\n  },\n  {\n    rowId: 3,\n    reorderable: true, //highlight-line\n    cells: [\n      { type: \"text\", text: \"\" },\n      { type: \"text\", text: \"\" }\n    ]\n  }\n]);","3-implement-the-handler-functions#3. Implement the handler functions":"reorderArray function is used to order columns or rows.\n// a helper function used to reorder arbitrary arrays\nconst reorderArray = <T extends {}>(arr: T[], idxs: number[], to: number) => {\n  const movedElements: T[] = arr.filter((_: T, idx: number) => idxs.includes(idx));\n  to = Math.min(...idxs) < to ? to += 1 : to -= idxs.filter(idx => idx < to).length;\n  const leftSide: T[] = arr.filter((_: T, idx: number) => idx < to && !idxs.includes(idx));\n  const rightSide: T[] = arr.filter((_: T, idx: number) => idx >= to && !idxs.includes(idx));\n  return [...leftSide, ...movedElements, ...rightSide];\n}\nconst handleColumnsReorder = (targetColumnId: Id, columnIds: Id[], dropPosition: DropPosition) => {\n  const to = columns.findIndex((column: Column) => column.columnId === targetColumnId);\n  const columnIdxs = columnIds.map((id: Id, idx: number) => columns.findIndex((c: Column) => c.columnId === id));\n  setRows(rows.map(row => ({ ...row, cells: reorderArray(row.cells, columnIdxs, to) })));\n  setColumns(reorderArray(columns, columnIdxs, to));\n}\nconst handleRowsReorder = (targetRowId: Id, rowIds: Id[], dropPosition: DropPosition) => {\n  setRows((prevRows) => {\n    const to = rows.findIndex(row => row.rowId === targetRowId);\n    const columnIdxs = rowIds.map(id => rows.findIndex(r => r.rowId === id));\n    return reorderArray(prevRows, columnIdxs, to);\n  });\n}\nPass the handler functions to your ReactGrid component and add enableRowSelection and enableColumnSelection properties to\nenable this type of events handling.\n<ReactGrid\n\trows={rows}\n\tcolumns={columns}\n\tonColumnsReordered={handleColumnsReordered} // highlight-line\n\tonRowsReordered={handleRowsReordered} // highlight-line\n\tenableRowSelection // highlight-line\n\tenableColumnSelection // highlight-line\n/>","live-demo#Live demo":""}},"/docs/3.0/2-implementing-core-features/4a-selections":{"title":"Selections","data":{"":"This feature is only available in PRO version\nReactGrid has three properties related to selections inside the grid via ReactGrid:\nenableRangeSelection\nenableRowSelection\nenableColumnSelection","enablerangeselection-property#enableRangeSelection property":"The range selection is the most common selection, but in case you want to use it, it's necessary to enable it before.\nYou can do multiple selections by holding the Ctrl or Command ⌘ key on Apple devices.\n<ReactGrid\n    {...props}\n    enableRangeSelection //highlight-line\n/>","enablerowselection-and-enablecolumnselection-property#enableRowSelection and enableColumnSelection property":"Way how enableRowSelection and enableColumnSelection property works is very similar.When you first click on:\nthe left cell of a row, the whole row will be selected, then you can expand this selection to other rows;\nthe top cell of the column, the whole column will be selected, then you can expand this selection to other columns.\nYou can then select or unselect any row/column by Ctrl or Command ⌘ key.If you click on the first top-left cell and enableColumnSelection is enabled then the column has a priority\nover the row in this particular case.\n<ReactGrid\n    {...props}\n    enableRowSelection //highlight-line\n    enableColumnSelection //highlight-line\n/>"}},"/docs/3.0/2-implementing-core-features/4-sticky":{"title":"Sticky rows and columns","data":{"introduction#Introduction":"ReactGrid allows you to stick chosen rows and columns at the top or left side and additionally on the right and at the bottom\nof the ReactGrid viewport only in PRO version. Sticky rows or columns will be visible at all times, no matter what the scroll position is.\nRight and bottom sticky ranges are only available in PRO version\nSticky rows and columns can be enabled by adding dedicated ReactGrid component properties:\nstickyTopRows\nstickyBottomRows\nstickyLeftColumns\nstickyRightColumns\nAll of these properties are numeric and determine the number of columns or rows sticky next to the grid's edges.","how-to-make-columns-and-rows-sticky#How to make columns and rows sticky?":"This guide is based on getting started.\nAdd some more data to the table, so that it's more likely for a scrollbar to appear\nor reduce the height of the grid container\nconst [columns] = React.useState<Column[]>(() => [\n  { columnId: \"Name\", width: 150 },\n  { columnId: \"Surname\", width: 100 },\n  { columnId: \"Birth Data\", width: 100 }, // highlight-line\n  { columnId: \"Phone\", width: 100 }, // highlight-line\n  { columnId: \"Company\", width: 150 },  // highlight-line\n  { columnId: \"Occupation\", width: 250 } // highlight-line\n]);\nconst [rows, setRows] = React.useState<Row[]>(() => [\n  {\n    rowId: 0,\n    cells: [\n      { type: \"header\", text: \"Name\" },\n      { type: \"header\", text: \"Surname\" },\n      { type: \"header\", text: \"Birth Data\" }, // highlight-line\n      { type: \"header\", text: \"Phone\" },  // highlight-line\n      { type: \"header\", text: \"Company\" }, // highlight-line\n      { type: \"header\", text: \"Occupation\" } // highlight-line\n    ]\n  },\n  {\n    rowId: 1,\n    cells: [\n      { type: \"text\", text: \"Thomas Anthony\" },\n      { type: \"text\", text: \"Goldman\" },\n      { type: \"date\", date: new Date(\"1989-04-01\") }, // highlight-line\n      { type: \"number\", value: 293827394 }, // highlight-line\n      { type: \"text\", text: \"Electronic Geek\" }, // highlight-line\n      { type: \"text\", text: \"Textile and furnishings occupation\" } // highlight-line\n    ]\n  },\n  {\n    rowId: 2,\n    cells: [\n      { type: \"text\", text: \"Susie Evelyn\" },\n      { type: \"text\", text: \"Spencer\" },\n      { type: \"date\", date: new Date(\"1970-12-02\") }, // highlight-line\n      { type: \"number\", value: 684739283 }, // highlight-line\n      { type: \"text\", text: \"Harold Powell\" }, // highlight-line\n      { type: \"text\", text: \"Concrete paving machine operator\" } // highlight-line\n    ]\n  },\n  {\n    rowId: 3,\n    cells: [\n      { type: \"text\", text: \"Mathew Lawrence\" },\n      { type: \"text\", text: \"Joshua\" },\n      { type: \"date\", date: new Date(\"1970-12-02\") }, // highlight-line\n      { type: \"number\", value: 684739283 }, // highlight-line\n      { type: \"text\", text: \"De-Jaiz Mens Clothing\" }, // highlight-line\n      { type: \"text\", text: \"Technical recruiter\" } // highlight-line\n    ]\n  },\n  {\n    rowId: 4,\n    cells: [\n      { type: \"text\", text: \"\" },\n      { type: \"text\", text: \"\" },\n      { type: \"date\", date: undefined }, // highlight-line\n      { type: \"number\", value: NaN }, // highlight-line\n      { type: \"text\", text: \"\" }, // highlight-line\n      { type: \"text\", text: \"\" } // highlight-line\n    ]\n  }\n]);\nUse the properties mentioned in the introduction to set the number of sticky ranges at each edge\nreturn (\n\t<ReactGrid\n\t\trows={rows}\n\t\tcolumns={columns}\n\t\tstickyLeftColumns={1} // highlight-line\n\t\tstickyRightColumns={1} // highlight-line\n\t\tstickyTopRows={1} // highlight-line\n\t\tstickyBottomRows={1} // highlight-line\n\t/>\n);","result#Result":"Here's how sticky rows and columns look in action (we recommend playing with this demo in the fullscreen mode):"}},"/docs/3.0/2-implementing-core-features/4b-fill-handle":{"title":"Fill handle","data":{"":"This feature is only available in PRO version\nReactGrid supports fill handle action in PRO version, but it is disabled by default. To turn it on you have to simply\nadd enableFillHandle property to ReactGrid component.\n<ReactGrid\n    {...props}\n    enableFillHandle //highlight-line\n/>\nNote that if an incoming change will not be handled by the app, then there will be no visible changes,\nthough the action was correctly performed."}},"/docs/3.0/2-implementing-core-features/5-context-menu":{"title":"Context menu","data":{"":"Context menu is only available in PRO version\nReactGrid comes with a custom context menu feature. Custom menu entries can be easily created thus\nallowing for personalized experiences.\nBy default, the context menu is disabled. You can enable it by providing a handler function\nto your ReactGrid using the onContextMenu property.","enabling-simple-context-menu#Enabling simple context menu":"This guide is based on handling data changes.\nUpdate imports by adding Id, SelectionMode\nand MenuOption interfaces\nimport { ReactGrid, CellChange, Row, Column, Id, MenuOption, SelectionMode } from \"@silevis/reactgrid\";\nImplement the context menu handler function\nThe menuOptions argument of simpleHandleContextMenu contains a list of default menu entries\nprovided by ReactGrid - copy, cut and paste.\nFor now, we'll simply define it, which will enable the default ReactGrid context menu.\nconst simpleHandleContextMenu = (\n    selectedRowIds: Id[],\n    selectedColIds: Id[],\n    selectionMode: SelectionMode,\n    menuOptions: MenuOption[]\n  ): MenuOption[] => {\n    return menuOptions;\n};\nreturn (\n  <ReactGrid\n    rows={rows}\n    columns={columns}\n    onCellsChanged={handleChanges}\n    onContextMenu={simpleHandleContextMenu} // highlight-line\n  />\n);\nHere's the result. Right-click anywhere in the grid to see the context menu.","advanced-example---removing-columns-and-rows#Advanced example - removing columns and rows":"The default menu, though pretty, may seem a bit lacklustre when it comes to the functionality it provides.\nLet's try and extend it a bit - we'll make it possible to remove columns and rows using the context menu.\nImplement a more advanced context menu handler function\nconst handleContextMenu = (\n  selectedRowIds: Id[],\n  selectedColIds: Id[],\n  selectionMode: SelectionMode,\n  menuOptions: MenuOption[]\n): MenuOption[] => {\n  if (selectionMode === \"row\") {\n    menuOptions = [\n      ...menuOptions,\n      {\n        id: \"removeRow\",\n        label: \"Remove row\",\n        handler: () => setRows(rows.filter(row => !selectedRowIds.includes(row.rowId)))\n      }\n    ];\n  }\n  if (selectionMode === \"column\") {\n    menuOptions = [\n      ...menuOptions,\n      {\n        id: \"removeColumn\",\n        label: \"Remove column\",\n        handler: () => {\n          const cols = columns.filter(column => !selectedColIds.includes(column.columnId));\n          const columnsIdxs = columns\n            .map((column, idx) => {\n              if (!cols.includes(column)) return idx;\n              return undefined;\n            })\n            .filter(idx => idx !== undefined);\n          setRows(rows.map(row => ({\n            ...row,\n            cells: row.cells.filter((_, idx) => !columnsIdxs.includes(idx))\n          })));\n          setColumns(cols);\n        }\n      }\n    ];\n  }\n  return menuOptions;\n};\nUpdate the ReactGrid component's properties. Note that columns and rows must be selectable for our feature to work.\nAfter all, we will be removing the currently selected row or column.\nreturn (\n  <ReactGrid\n    rows={rows}\n    columns={columns}\n    onCellsChanged={handleChanges} // highlight-line\n    onContextMenu={handleContextMenu} // highlight-line\n    enableColumnSelection // highlight-line\n    enableRowSelection // highlight-line\n  />\n)","live-demo#Live demo":"You can see the effect of the changes we've just introduced in the demo below.\nTo test the new feature, simply select a column or a row by clicking a header cell or one of the leftmost cells,\nthen right-click anywhere and use the new menu entry."}},"/docs/3.0/2-implementing-core-features/5a-groupId":{"title":"Group Id","data":{"":"ReactGrid introduces a brand new feature called group Id. The main purpose of it is to avoid queueing changes\nby marking cells on groupId property using Id interface.Marked cell with a groupId has a following behavior. While you paste data or execute fill handle action: the change will\nbe queued only for a cell with the same groupId. If the change can't be queued, then you will be warned in browser's console.\nEven if no cell is marked, then they are treated as a separate group.Every cell with declared groupId renders with additional span element (containing its value) inside a cell if\nyou have passed enableGroupIdRender property:\n<ReactGrid\n    {...props}\n    enableFillHandle\n    enableRangeSelection\n    enableGroupIdRender // highlight-line\n/>\ngroupId property is available in every cell template because it's provided by Cell\ninterface.","live-example#Live example":"An example shows that a few cells were marked with group: A or group: B group Id.\nTry and select any range and then copy and paste or use fill handle to clone data."}},"/docs/3.0/2-implementing-core-features/6-highlights":{"title":"Highlights","data":{"highlights-usage#Highlights usage":"This guide is based on getting started.Highlights allow you to alter arbitrary cells in the grid\nby applying custom CSS classes to them or by setting their border colours.\nImport the Highlight interface\nDefine an array of Highlight objects\nconst highlights: Highlight[] = [\n  { columnId: \"Name\", rowId: 1, borderColor: \"#00ff00\" },\n  { columnId: \"Surname\", rowId: 2, borderColor: \"#0000ff\" },\n  { columnId: \"Name\", rowId: 3, borderColor: \"#ff0000\" },\n];\nPass the highlights object array to your component\nreturn (\n  <ReactGrid\n    rows={rows}\n    columns={columns}\n    highlights={highlights} // highlight-line\n  />\n);","live-demo#Live demo":""}},"/docs/3.0/2-implementing-core-features/7-managing-focus":{"title":"Focus management","data":{"focus-locations#Focus locations":"ReactGrid has two properties related to focus location inside the grid via ReactGrid:\nfocusLocation\ninitialFocusLocation","initialfocuslocation-property#initialFocusLocation property":"You can set focus location at the first render of ReactGrid. Then this property is used no more.\n<ReactGrid\n    {...props}\n    initialFocusLocation={{ columnId: 'col-2', rowId: 'row-2' }} //highlight-line\n/>","focuslocation-property#focusLocation property":"Defining focusLocation property is superior to pointer and keyboard actions, so you have to manage it all over time.\nIf focusLocation property has falsy value then it is ignored.\nDefined initialFocusLocation is immediately overridden by focusLocation\n<ReactGrid\n    {...props}\n    initialFocusLocation={{ columnId: 'col-3', rowId: 'row-3' }} //highlight-line\n    focusLocation={{ columnId: 'col-2', rowId: 'row-2' }} //highlight-line\n/>"}},"/docs/3.0/2-implementing-core-features/9-keyboard-shortcuts":{"title":"Keyboard shortcuts","data":{"":"Some of the available shortcuts are related with only PRO functionality","about-keyboard-events#About keyboard events":"ReactGrid allows you to interact with the grid using keyboard shortcuts in a way known from other spreadsheet-like apps.At this moment we plan to add few callback events for clipboard action like copying, pasting and cutting.","keyboard-shortcuts#Keyboard shortcuts":"Shortcut\tAction\t↑\tMoves cell focus one cell up (if is focusable)\t↓\tMoves cell focus one cell down (if is focusable)\t←\tMoves cell focus to the left (if is focusable)\t→\tMoves cell focus to the right (if is focusable)\tEnter\tOpens cell editor if cell is focused or moves focus down inside range selection\tDelete or Backspace\tWipe selected range or only focused location\tTab\tMoves focus to the right if single cell is selected or moves focus to the right inside range selection\tHome\tMoves focus to the first column\tEnd\tMoves focus to the last column\tPageUp\tMoves focus up by one page (visible number of rows)\tPageDown\tMoves focus down by one page (visible number of rows)\tEscape\tAborts cell edition without changing it\tCtrl + Space\tExpands selection in vertical direction (only on Apple devices)\tCtrl  + Shift + Home or  ⌘ + Shift + Home\tSelects all cells above currect selection\tCtrl + Shift + End or  ⌘ + Shift +  End\tSelects all cells below currect selection\t⌘ + A or Ctrl + A\tSelects all cells\t⌘ + Home or Ctrl + Home\tSelects top left cell\t⌘ + End or Ctrl + End\tSelects bottom right cell\tCtrl + End\tSelect whole column on Windows\tShift + Enter\tCloses cell editor if it is opened and moves focus cell above last edited cell\tShift + ↑\tSelects one cell above\tShift + ↓\tSelects one cell below\tShift + ←\tSelects one cell on the left\tShift + →\tSelects one cell on the right\tShift + Tab\tMoves focus to the left if single cell is selected or moves focus to the left inside range selection\tShift + Enter\tMoves focus one cell above if single cell is selected or moves focus up inside range selection\tShift + Space\tExpands selection in vertical direction (from top to bottom)\tShift + Home\tExpands selection to the first column\tShift + End\tExpands selection to the last column\tShift + PageUp\tIncrease or decrease selection by single page\tShift + PageDown\tIncrease or decrease selection by single page"}},"/docs/3.0/2-implementing-core-features/9a-full-width-header":{"title":"Full width header","data":{"introduction#Introduction":"Full width header feature is experimental and it can be changed in the future\nThis feature extends width of top sticky pane to full available space inside ReactGrid's parent.","usage#Usage":"Add enableFullWidthHeader property to ReactGrid component and add any number of stickyTopRows. In our example, the sample\nReactGrid component was also wrapped inside a div element that is wider than all columns.\nreturn (\n    <ReactGrid\n      rows={rows}\n      columns={columns}\n      enableFullWidthHeader // highlight-line\n      stickyTopRows={1}  // highlight-line\n    />\n);","#":"","issues#Issues":"If the width of ReactGrid's parent is less then the sum of all the columns (including left sticky), there might be bugs\nenabling right and bottom sticky panes can cause bugs related with scrolling, ranges selection etc."}},"/docs/3.0/2-implementing-core-features/8-embedding-on-website":{"title":"Embedding on website","data":{"about-reactgrig-embedding-virtual-scrolling-and-sticky-panes-pinning#About ReactGrig embedding, virtual scrolling and sticky panes pinning":"ReactGrid component isn't limited by height and width so its behaviour can change a little bit depending on its scrollable parent element.ReactGrid appends scroll event to its immediate scrollable parent and lets itself expand to full height/width with the option of\nconstant observation of available viewport size.Limiting the size of ReactGrid can be achieved by adding CSS class listed below\n(bear in mind that the total rows height must be bigger than scrollable element height)\n.reactgrid-wrapper {\n    height: 100px;\n    overflow: scroll;\n}\nMultiple nested scrollable elements can cause unexpected experience like incorrect cell editor position, wrong focus location etc.\nIf all rows/columns can't be rendered in viewport - virtual scrolling still works fine.","example-reactgrid-component-limited-by-the-height-of-its-parent#Example: ReactGrid component limited by the height of its parent":"In this case, not all the passed rows can be rendered, so scrollbar appears and sticky pane is pinned directly to the top of the\nparent element.","example-reactgrid-component-not-limited-by-the-height-of-its-parent#Example: ReactGrid component NOT limited by the height of its parent":"ReactGrid renders all the passed rows and columns if sticky panes are passed - they are pinned directly to the edge\nof body element."}},"/docs/3.0/2-implementing-core-features/9b-internationalization":{"title":"Internationalization","data":{"":"Some of the translations are available for the PRO version","adding-i18n#Adding i18n":"ReactGrid has a few optional text labels that you could replace. All of the available translations are defined in\nTextLabels interface. You can create an object, and then pass it to labels\nproperty.\nreturn (\n\t<ReactGrid\n    {...props}\n    labels={{\n        copyLabel: 'Copy me!',\n        pasteLabel: 'Paste me!',\n        cutLabel: 'Cut me!',\n    }}\n\t/>\n);","locale-inside-cell-templates#Locale inside cell templates":"Some cell templates (NumberCell, DateCell,\nTimeCell) contain inside optional format field. This field uses\nIntl object of ECMAScript Internationalization API.\nWe suggest formatting cells content via mentioned API."}},"/docs/3.0/4-cell-templates":{"title":"Cell templates","data":{"idea-of-cell-templates#Idea of cell templates":"In getting started chapter we declared cells array to be part of ReactGrid property.Each cell template has its own and unique behavior, content formatting and styling.Nothing stops you from creating your custom cell - read about creating your own cell template.In the listing below we declared two cells of header type, and they are related to the interface of HeaderCell\ntemplate.\ncells: [\n    { type: \"header\", text: \"Name\" },\n    { type: \"header\", text: \"Surname\" }\n]\nEvery cell object must contain type attribute, other keys depend on the exact type of a specific cell.","builtin-cell-templates#Builtin cell templates":"CheckboxCell\nDateCell\nEmailCell\nGroupCell\nHeaderCell\nNumberCell\nTextCell\nTimeCell"}},"/docs/3.0/4-cell-templates/2-CheckboxCell":{"title":"CheckboxCell","data":{"":"This cell type displays checkbox input. This template has disabled edit mode.","implementation#Implementation":"Open CheckboxCell implementation on  github","interface-declaration#Interface declaration":"interface CheckboxCell extends Cell {\n    type: 'checkbox';\n    checked: boolean;\n    checkedText?: string;\n    uncheckedText?: string;\n}\nProperty name\tType\tProperty description\ttype\tcheckbox\tType of cell template\tchecked\tboolean\tCurrent state of checked attribute in input element\tcheckedText?\tstring\tText of \"checked text input\", used while getting compatible cell, by default: 1\tuncheckedText?\tstring\tText of \"unchecked text input\",  used while getting compatible cell, by default: `` (empty string)"}},"/docs/3.0/4-cell-templates/3-DateCell":{"title":"DateCell","data":{"":"This template formats Date object and displays default browser date picker in edit mode.","implementation#Implementation":"Open DateCell implementation on  github","interface-declaration#Interface declaration":"interface DateCell extends Cell {\n    type: 'date';\n    date?: Date;\n    format?: Intl.DateTimeFormat;\n}\nProperty name\tType\tProperty description\ttype\tdate\tType of cell template\tdate?\tDate\tDate object, optional\tformat?\tIntl.DateTimeFormat\tFormats date, if undefined formats date according to the currect browser locale"}},"/docs/3.0/4-cell-templates/4-EmailCell":{"title":"EmailCell","data":{"":"This cell renders text value with the possibility to validate its value and wrap the result into React.ReactNode objects.","implementation#Implementation":"Open EmailCell implementation on  github","interface-declaration#Interface declaration":"interface EmailCell extends Cell {\n    type: 'email',\n    text: string,\n    validator?: (text: string) => boolean,\n    renderer?: (text: string) => React.ReactNode\n}\nProperty name\tType\tProperty description\ttype\temail\tType of cell template\ttext\tstring\tText content of cell\tvalidator?\t(text: string) => boolean\tOptional validation function, if undefined - returns true\trenderer?\t(text: string) => React.ReactNode\tOptional, gives oportunity to wrap text property into any ReactNode object"}},"/docs/3.0/4-cell-templates/8-TextCell":{"title":"TextCell","data":{"":"This template allows to display text as a string value. Optionally it also gives\na possibility to change rendering method and validate displaying text.","implementation#Implementation":"Open TextCell implementation on  github","interface-declaration#Interface declaration":"interface TextCell extends Cell {\n    type: 'text',\n    text: string,\n    validator?: (text: string) => boolean,\n    renderer?: (text: string) => React.ReactNode\n}\nProperty name\tType\tProperty description\ttype\theader\tType of cell template\ttext\tstring\tText content of cell\tvalidator?\t(text: string) => boolean\tOptional validation function, if undefined - returns true\trenderer?\t(text: string) => React.ReactNode\tOptional, gives oportunity to wrap text property into any ReactNode object"}},"/docs/3.0/4-cell-templates/7-NumberCell":{"title":"NumberCell","data":{"":"Displays number, this cell allows to customize format number values using Intl.NumberFormat.","implementation#Implementation":"Open NumberCell implementation on  github","interface-declaration#Interface declaration":"interface NumberCell extends Cell {\n    type: 'number';\n    value: number;\n    format?: Intl.NumberFormat;\n    nanToZero?: boolean;\n    hideZero?: boolean;\n}\nProperty name\tType\tProperty description\ttype\theader\tType of cell template\tvalue\tnumber\tValue of cell\tformat?\tIntl.NumberFormat\tFormats value, if undefined formats number according to currect browser locale\tnanToZero?\tboolean\tIf value equals NaN then displays 0\thideZero?\tboolean\tIf displayed value equals 0 then value is not rendered"}},"/docs/3.0/4-cell-templates/5-GroupCell":{"title":"GroupCell","data":{"":"GroupCell contains data about a single node in the tree structure of the data. This cell template renders text with\nthe preceding chevron.Implementation of grouping functionality remains on developer (e.g., creating tree structure of cells,\nfiltering rows available to display, creating indents).","implementation#Implementation":"Open GroupCell implementation on  github","interface-declaration#Interface declaration":"interface GroupCell extends Cell {\n    type: 'group';\n    text: string;\n    isExpanded?: boolean;\n    hasChildren?: boolean;\n    parentId?: Id;\n    indent?: number;\n}\nProperty name\tType\tProperty description\ttype\tgroup\tType of cell template\ttext\tstring\tText of cell content\tisExpanded?\tboolean\tIs node expaned (displays chevron char as opened/closed)\thasChildren?\tboolean\tDetermines if a node element has children\tparentId?\tId\tId of parent node (cell), if undefined the node becomes a root\tindent?\tnumber\tIndent size of cell content"}},"/docs/3.0/4-cell-templates/6-HeaderCell":{"title":"HeaderCell","data":{"":"The main purpose of this cell is to mark its content as not focusable and read-only. Usually used to mark header rows\nand columns.","implementation#Implementation":"Open HeaderCell implementation on  github","interface-declaration#Interface declaration":"interface HeaderCell extends Cell {\n    type: 'header',\n    text: string,\n}\nProperty name\tType\tProperty description\ttype\theader\tType of cell template\ttext\tstring\tContent of cell"}},"/docs/3.0/5-create-your-own-cell-template":{"title":"Create your own cell template","data":{"introduction#Introduction":"Creating a cell template is the best way to customize data visualization and behaviour in ReactGrid.\nYou can define your own one and then use it as other built-in cell types.In this example, we will explain how to make it.Let's imagine that you need to implement a brand new cell for displaying a country flag.Expected functionality:\nIn edit mode a cell allows you to type in text without any constraints\nWhen a cell is displayed, it should show a country flag based on the cell text\nLet's get started!","1-define-flag-cell-interface#1. Define flag cell interface":"For this tutorial we are going to use the previous project - handling changes.type attribute is necessary in any cell template, in our sample we will refer to this cell template by flag.\ntext attribute will store our text and it's also necessary.\nexport interface FlagCell extends Cell {\n  type: \"flag\";\n  text: string;\n}","2-data-holders#2. Data holders":"At the beginning we should update columns and rows displayed by the grid.\nCell type in row 1, 2 and 3 will be changed to flag at the end.\nconst [columns] = React.useState<Column[]>(() => [{ columnId: 0, width: 100 }]);\nconst [rows, setRows] = React.useState<Row<DefaultCellTypes | FlagCell>[]>(\n  () => [\n    {\n      rowId: 0,\n      height: 40,\n      cells: [{ type: \"header\", text: \"Flag\" }],\n    },\n    {\n      rowId: 1,\n      height: 40,\n      cells: [{ type: \"text\", text: \"rus\" }],\n    },\n    {\n      rowId: 2,\n      height: 40,\n      cells: [{ type: \"text\", text: \"usa\" }],\n    },\n    {\n      rowId: 3,\n      height: 40,\n      cells: [{ type: \"text\", text: \"\" }],\n    },\n  ]\n);","3-creating-necessary-files#3. Creating necessary files":"Create new file named FlagCellTemplate.tsx, add the same imports as in the listing below and make flag-cell-style.cssfile that\nwill contain some CSS styles (don't forget to import it into your project's file).\n// FlagCellTemplate.tsx\nimport * as React from \"react\";\nimport {\n  CellTemplate,\n  Cell,\n  Compatible,\n  Uncertain,\n  UncertainCompatible,\n  isNavigationKey,\n  getCellProperty,\n  isAlphaNumericKey,\n  keyCodes,\n} from \"@silevis/reactgrid\";\nimport \"./flag-cell-style.css\";","4-creating-flagcelltemplate-class#4. Creating FlagCellTemplate class":"For all defined methods below it is necessary to display and interface the flag cell with internal ReactGrid model correctly.\ngetCompatibleCell as a parameter gets an incoming cell and returns a compatible cell (with text and value\nattribute required by Compatible type).\nIn more complex examples getCellProperty may throw an exception if the required cell field is undefined.\ngetCompatibleCell(uncertainCell: Uncertain<FlagCell>): Compatible<FlagCell> {\n    const text = getCellProperty(uncertainCell, 'text', 'string');\n    const value = parseFloat(text);\n    return { ...uncertainCell, text, value };\n}\nhandleKeyDown method handles keyDown event on this cell template. Here it just returns unchanged cell and enables\nedit mode when a user performed a click or pressed ENTER key.\nhandleKeyDown(\n    cell: Compatible<FlagCell>,\n    keyCode: number,\n    ctrl: boolean,\n    shift: boolean,\n    alt: boolean\n): { cell: Compatible<FlagCell>; enableEditMode: boolean } {\n    if (!ctrl && !alt && isAlphaNumericKey(keyCode))\n        return { cell, enableEditMode: true };\n    return {\n        cell,\n        enableEditMode: keyCode === keyCodes.POINTER || keyCode === keyCodes.ENTER\n    };\n}\nupdate - as we are not sure if an incoming cell has the same interface like FlagCell so we mark it\nas UncertainCompatible (the incoming cell has attributes provided by Compatible\nbut it can have other attributes like date from DateCell). In our case, we just copy cell and replace text value.\nupdate(cell: Compatible<FlagCell>, cellToMerge: UncertainCompatible<FlagCell>): Compatible<FlagCell> {\n    return this.getCompatibleCell({ ...cell, text: cellToMerge.text });\n}\nrender method returns the content of a cell. In edit mode we will display input element. The change which is made in the\ncell input is propagated outside ReactGrid by onCellChanged function.\nrender(\n    cell: Compatible<FlagCell>,\n    isInEditMode: boolean,\n    onCellChanged: (cell: Compatible<FlagCell>, commit: boolean) => void\n): React.ReactNode {\n  if (!isInEditMode) {\n    const flagISO = cell.text.toLowerCase(); // ISO 3166-1, 2/3 letters\n    const flagURL = `https://restcountries.eu/data/${flagISO}.svg`;\n    const alternativeURL = `https://upload.wikimedia.org/wikipedia/commons/0/04/Nuvola_unknown_flag.svg`;\n    return (\n      <div\n        className=\"rg-flag-wrapper\"\n        style={{ backgroundImage: `url(${flagURL}), url(${alternativeURL})` }}\n      />\n    );\n  }\n  return (\n    <input\n      ref={input => {\n        input && input.focus();\n      }}\n      defaultValue={cell.text}\n      onChange={e =>\n        onCellChanged(\n          this.getCompatibleCell({ ...cell, text: e.currentTarget.value }),\n          false\n        )\n      }\n      onCopy={e => e.stopPropagation()}\n      onCut={e => e.stopPropagation()}\n      onPaste={e => e.stopPropagation()}\n      onPointerDown={e => e.stopPropagation()}\n      onKeyDown={e => {\n      if (isAlphaNumericKey(e.keyCode) || isNavigationKey(e.keyCode))\n        e.stopPropagation();\n      }}\n    />\n  );\n}","5-styling#5. Styling":"To set a flag as the background covering the div element, we created CSS rg-flag-wrapper class.\nAll of the cells have a class name created based on the cell type attribute. In our case, the cell class name will be rg-flag-cell.\nAs rg-cell is a flex element we center its content with justify-content: center; attribute.\n.rg-flag-cell {\n  justify-content: center;\n}\n.rg-flag-wrapper {\n  width: 50%;\n  height: 80%;\n  background-size: cover;\n  border: 1px solid #cccccc;\n  background-position: center center;\n  background-repeat: no-repeat;\n}","6-finishing#6. Finishing":"Go back to index.tsx file and add customCellTemplates property as shown below and also change type: \"text\" to type: \"flag\":\n// ...\nconst [rows, setRows] = React.useState<Row<DefaultCellTypes | FlagCell>[]>(\n  () => [\n    {\n      rowId: 0,\n      height: 40,\n      cells: [{ type: \"header\", text: \"Flag\" }],\n    },\n    {\n      rowId: 1,\n      height: 40,\n      cells: [{ type: \"flag\", text: \"rus\" }], // highlight-line\n    },\n    {\n      rowId: 2,\n      height: 40,\n      cells: [{ type: \"flag\", text: \"usa\" }], // highlight-line\n    },\n    {\n      rowId: 3,\n      height: 40,\n      cells: [{ type: \"flag\", text: \"\" }], // highlight-line\n    },\n  ]\n);\nreturn (\n  <ReactGrid\n    rows={rows}\n    columns={columns}\n    onCellsChanged={handleChanges}\n    customCellTemplates={{ flag: new FlagCellTemplate() }} //highlight-line\n  />\n);","result#Result":""}},"/docs/3.0/4-cell-templates/9-TimeCell":{"title":"TimeCell","data":{"":"This template formats Date object and displays default browser time picker in edit mode.\nKeep in mind: time attribute that stores Date object instance will be stored with the date of January 1st, 1970 UTC.","implementation#Implementation":"Open TimeCell implementation on  github","interface-declaration#Interface declaration":"interface TimeCell extends Cell {\n    type: 'time';\n    time?: Date;\n    format?: Intl.DateTimeFormat;\n}\nProperty name\tType\tProperty description\ttype\tdate\tType of cell template\tdate?\tDate\tDate object, optional\tformat?\tIntl.DateTimeFormat\tFormats time, if undefined formats it according to current browser locale"}},"/docs/3.0/6-styling":{"title":"Styling","data":{"":"In this chapter, you will learn about simple and advanced ReactGrid components styling using Sass variables.\nBasic styling\nAdvanced styling\nSass variables"}},"/docs/3.0/6-styling/0-basic-styling":{"title":"Basic styling","data":{"introduction#Introduction":"For the correct display of the component it's required to import the basic styles contained directly inside\n@silevis/reactgrid package.","importing#Importing":"Styles are a necessary part of ReactGrid. For a correct display you have to import ReactGrid into your project.\n/* your-styles.css */\n@import '@silevis/reactgrid/styles.css';\nor if you use Sass preprocessor:\n/* your-styles.scss */\n@import '@silevis/reactgrid/styles.scss';\nYou can only import files that you need and then override variables yourself:\n/* your-styles.scss */\n@import './default-colors.scss';\n@import './default-sizing.scss';\n@import './cell-templates-default-colors.scss';\n@import './mapping.scss';\n@import './cell-templates.scss';\n@import './main.scss';"}},"/docs/3.0/6-styling/1-advanced-styling":{"title":"Advanced styling","data":{"":"ReactGrid lets you style all key components using Sass variables.Before you use .scss files you have to install node-sass package:\nnpm install node-sass\nTo override default styles of ReactGrid you have to assign new values\n(available variables) and then import all  necessary .scss files.\nIf variable is not passed before getting imported core.scss it will not be modified.Here's an example of how to add custom focus style on your grid.\n// Your custom color\n$primary-color: #3579f8;\n@import '@silevis/reactgrid/styles.scss';\nSee full styling example below:\nIf you use multiple grids on the same page, make sure your grid styles are 'local'.\n// Independent ReactGrid classess\n#reactgrid-red {\n    $primary-color: red;\n    @import '@silevis/reactgrid/styles.scss';\n}\n#reactgrid-blue {\n    $primary-color: blue;\n    @import '@silevis/reactgrid/styles.scss';\n}\nWrap ReactGrid component into div element with class name:\n<div id=\"reactgrid-red\">\n    <ReactGrid {...props}/>\n</div>\n<div id=\"reactgrid-blue\">\n    <ReactGrid {...props}/>\n</div>"}},"/docs/3.0/6-styling/2-sass-variables":{"title":"Sass variables","data":{"":"ReactGrid uses an expanded set of variables you can override.","color-related-variables#Color related variables":"","color-variables#Color variables":"$primary-color:                     #3579f8 !default;\n$bg-color:                          #ffffff !default;\n$sticky-bg-color:                   #ffffff !default;\n$shadow-color:                      #000000 !default;\n$resize-line-color:                 #74b9ff !default;\n$resize-hint-bg-color:              $resize-line-color !default;\n$resize-handle-gb-color:            $primary-color !default;\n$row-line-color:                    #e5e5e5 !default;\n$col-line-color:                    #e5e5e5 !default;\n$cell-editor-bg-color:              #ffffff !default;\n$cell-editor-border-color:          $primary-color !default;\n$fillhandle-action-border-color:    #000000 !default;\n$partial-area-gb-color:             $primary-color !default;\n$partial-area-border-color:         $primary-color !default;\n$checkbox-checked:                  $primary-color !default;\n$checkbox-unchecked:                #eeeeee !default;\n$checkbox-hover:                    #cccccc !default;\n$checkbox-mark:                     #ffffff !default;","shadow-variables#Shadow variables":"$shadow-blur-radius:    7px !default; \n$shadow-spread-radius:  -3px !default; \n$shadow-length:         3px !default; \n$cell-editor-shadow:    1px 1px 6px !default;","context-menu-variables#Context menu variables":"$context-menu-shadow: 0px 0px 8px 2px !default;","opacity-variables#Opacity variables":"$opacity-80:        0.8 !default;\n$opacity-35:        0.35 !default;\n$opacity-20:        0.2 !default;\n$opacity-15:        0.15 !default;\n$opacity-10:        0.1 !default;\n$opacity-01:        0.01 !default;","size-related-variables#Size related variables":"$cell-font-size:                        1em !default;\n$context-menu-font-size:                1em !default;\n$row-separator-line-width:              1px !default;\n$col-separator-line-width:              1px !default;\n$cell-padding:                          0 4px !default;\n$cell-focus-border-width:               2px !default;\n$celleditor-border-width:               2px !default;\n$celleditor-padding-top:                1px !default;\n$fill-handle-area:                      40px !default;\n$fill-handle-square:                    6.5px !default;\n$fill-handle-border-width:              1px !default;\n$resize-handle-area:                    11px !default;\n$resize-handle-line-width:              6px !default;\n$line-size:                             2px !default;\n$partial-area-border-width:             1px !default;\n$partial-area-selected-border-width:    1px !default;\n$checkbox-size:                         18px !default;\n$context-menu-option-padding:           8px 20px 8px 15px !default;","core-cell-templates-variables#Core cell templates variables":"$template-checkbox-size:    20px !default;\n$template-font-size:        1em !default;\n$template-bg-color:         transparent !default;\n$template-padding:          0 !default;\n$template-margin:           0 !default;\n$template-content-invalid:  rgb(255, 0, 0) !default;"}},"/docs/3.0/7-api/0-interfaces/1-reactgrid-props":{"title":"ReactGrid & ReactGridProps","data":{"":"ReactGrid component has two essential properties which you must pass in properties to render - columns and rows.","definition#Definition":"interface ReactGridProps {\n    readonly columns: Column[];\n    readonly rows: Row<Cell>[];\n    readonly customCellTemplates?: CellTemplates;\n    readonly focusLocation?: CellLocation;\n    readonly initialFocusLocation?: CellLocation;\n    readonly highlights?: Highlight[];\n    readonly stickyTopRows?: number;\n    readonly stickyBottomRows?: number;\n    readonly stickyLeftColumns?: number;\n    readonly stickyRightColumns?: number;\n    readonly enableFillHandle?: boolean;\n    readonly enableRangeSelection?: boolean;\n    readonly enableRowSelection?: boolean;\n    readonly enableColumnSelection?: boolean;\n    readonly labels?: TextLabels;\n    readonly enableFullWidthHeader?: boolean;\n    readonly enableGroupIdRender?: boolean;\n    readonly onCellsChanged?: (cellChanges: CellChange[]) => void;\n    readonly onFocusLocationChanged?: (location: CellLocation) => void;\n    readonly onFocusLocationChanging?: (location: CellLocation) => boolean;\n    readonly onColumnResized?: (columnId: Id, width: number, selectedColIds: Id[]) => void;\n    readonly onRowsReordered?: (targetRowId: Id, rowIds: Id[], dropPosition: DropPosition) => void;\n    readonly onColumnsReordered?: (targetColumnId: Id, columnIds: Id[], dropPosition: DropPosition) => void;\n    readonly onContextMenu?: (selectedRowIds: Id[], selectedColIds: Id[], selectionMode: SelectionMode, menuOptions: MenuOption[]) => MenuOption[];\n    readonly canReorderColumns?: (targetColumnId: Id, columnIds: Id[], dropPosition: DropPosition) => boolean;\n    readonly canReorderRows?: (targetRowId: Id, rowIds: Id[], dropPosition: DropPosition) => boolean;\n}","properties#Properties":"Name\tType\tDescription\tcolumns\tColumns[]\tColumn's data\trows\tRows<Cell>[]\tRow's data\tcustomCellTemplates?\tCellTemplates\tSet of available custom cell templates\tfocusLocation?\tCellLocation\tFocus position (managed constantly by outer app)\tinitialFocusLocation?\tCellLocation\tInitial position of focus\thighlights?\tHighlight[]\tArray of highlight positions\tstickyTopRows?\tnumber\tAmount of rows which are frozen at the top\tstickyBottomRows?\tnumber\tAmount of rows which are frozen at the bottom\tstickyLeftColumns?\tnumber\tAmount of columns which are sticky on the left side\tstickyRightColumns?\tnumber\tAmount of columns which are sticky on the right side\tenableFillHandle?\tboolean\tSet true to enable cell fill feature (by default false)\tenableRangeSelection?\tboolean\tSet true to enable selection feature (by default false)\tenableRowSelection?\tboolean\tSet true to enable row selection feature (by default false)\tenableColumnSelection?\tboolean\tSet true to enable column selection feature (by default false)\tlabels?\tTextLabels\tObject that contains labels of texts used by ReactGrid\tenableFullWidthHeader?\tboolean\tSet true to enable full width header (by default false, feature is experimental)\tenableGroupIdRender?\tboolean\tSet true to enable groupId element rendering (by default false)","callbacks#Callbacks":"Name\tType\tDescription\tonCellsChanged?\t(cellChanges: CellChange[]) => void;\tCalled when cell property (e.g. value) was changed\tonFocusLocationChanged?\t(location: CellLocation) => void;\tFocus position has been changed\tonFocusLocationChanging?\t(location: CellLocation) => boolean;\tCalled when trying to change focus location. Return false to prevent position changing\tonColumnResized?\t(columnId: Id, dropPosition: DropPosition) => void;\tCallback called when column resize action was ended\tonRowsReordered?\t(targetRowId: Id, rowIds: Id[], dropPosition: DropPosition) => void;\tCallback called when row reorder action was ended\tonColumnsReordered?\t(targetColumnId: Id, columnIds: Id[], dropPosition: DropPosition) => void;\tCallback called when column reorder action was ended\tonContextMenu?\t(selectedRowIds: Id[], selectedColIds: Id[], selectionMode: SelectionMode, menuOptions: MenuOption[]) => MenuOption[];\tCalled when user opens context menu inside grid, used to compose own menu options\tcanReorderColumns?\t(targetColumnId: Id, columnIds: Id[], dropPosition: DropPosition) => boolean;\tAllow or not to change specific columns order\tcanReorderRows?\t(targetRowId: Id, rowIds: Id[], dropPosition: DropPosition) => boolean;\tAllow or not to change specific rows order"}},"/docs/3.0/7-api":{"title":"API Reference","data":{"":"ReactGrid API contains interfaces, types and functions exported from ReactGrid package to compose grids,\ndefine custom behaviour and data visualization.\nInterfaces\nTypes\nFunctions & Enums"}},"/docs/3.0/7-api/0-interfaces":{"title":"Interfaces","data":{"":"ReactGrid API provides following interfaces:","interfaces#Interfaces":"ReactGridProps\nRow\nColumn\nCell\nCellTemplates\nCellTemplate\nCellChange\nCellLocation\nCellStyle\nMenuOption\nHighlight\nTextLabels"}},"/docs/3.0/7-api/0-interfaces/3-column":{"title":"Column","data":{"":"This interface represents column in grid. Column interface contains only one necessary property: columnId.","definition#Definition":"interface Column {\n    readonly columnId: Id;\n    readonly width?: number;\n    readonly reorderable?: boolean;\n    readonly resizable?: boolean;\n}","properties#Properties":"Property name\tType\tProperty description\tcolumnId\tId\tUnique Id in all columns array\twidth?\tnumber\tWidth of each grid column (in default set to 150px)\treorderable?\tboolean\tAllow column to change its position in grid, default: false (row reorder implementation is on the developer's side)\tresizable?\tboolean\tAllow column to change is width in grid, default: false (row resize implementation is on the developer's side)"}},"/docs/3.0/7-api/0-interfaces/4-cell":{"title":"Cell","data":{"":"Cell interface is a base for built-in cell templates and your own, it has only one necessary property - type.","definition#Definition":"interface Cell {\n    type: string;\n    groupId?: Id;\n    style?: CellStyle;\n    className?: string;\n}","properties#Properties":"Properties\tType\tProperties description\ttype\tstring\tName of cell type, must be unique\tgroupId\tId\tId of group to which this cell belongs to\tstyle?\tCellStyle\tAllowed style properties contained in CellStyle interface\tclassName?\tstring\tAdditional CSS classes"}},"/docs/3.0/7-api/0-interfaces/5-cell-template":{"title":"CellTemplate","data":{"":"CellTemplate is an interface used for communication between ReactGrid and a cell.\nAt this stage if you are still not familiar with cell marker interfaces, it might be helpful to read about them:\nCompatible\nUncertainCompatible\nUncertain","definition#Definition":"interface CellTemplate<TCell extends Cell = Cell> {\n    // Validate and convert to compatible cell type\n    getCompatibleCell(uncertainCell: Uncertain<TCell>): Compatible<TCell>;\n    // Returns true if the data in the cell is not replacable\n    // Default: _ => true\n    isFocusable?(cell: Compatible<TCell>): boolean;\n    // Update cell based on new props\n    // If not implemented, cell will be read-only\n    update?(cell: Compatible<TCell>, cellToMerge: UncertainCompatible<TCell>): Compatible<TCell>;\n    // The keyCode represents the key pressed on the keyboard, or 1 for a pointer event (double click).\n    // Returns the cell data either affected by the event or not.\n    // Default: cell => { cell, enableEditMode: false }\n    handleKeyDown?(cell: Compatible<TCell>, keyCode: number, ctrl: boolean, shift: boolean, alt: boolean): { cell: Compatible<TCell>; enableEditMode: boolean };\n    // Custom styles based on cell data applied to the cells div element\n    // Default: _ => cell.style | {}\n    getStyle?(cell: Compatible<TCell>, isInEditMode: boolean): CellStyle;\n    // Custom class names based on cell data applied to the cells div element\n    // Default: _ => cell.className | ''\n    getClassName?(cell: Compatible<TCell>, isInEditMode: boolean): string;\n    // Render the cell content\n    render(cell: Compatible<TCell>, isInEditMode: boolean, onCellChanged: (cell: Compatible<TCell>, commit: boolean) => void): React.ReactNode;\n}","properties#Properties":"Method\tReturns\tDescription\tgetCompatibleCell(uncertainCell: Uncertain<TCell>)\tCompatibleCell<TCell>\tValidates and converts into a compatible cell type\tisFocusable?(cell: Compatible<TCell>)\tboolean\tMarks a cell as focusable or not\tupdate?(cell: Compatible<TCell>, cellToMerge: UncertainCompatible<TCell>)\tCompatibleCell<TCell>\tUpdates cell based on new properties, if not implemented, a cell will be read-only\thandleKeyDown?(cell: Compatible<TCell>, keyCode: number, ctrl: boolean, shift: boolean, alt: boolean)\t{ cell: CompatibleCell<TCell>; enableEditMode: boolean }\tReturns the cell data either affected by an event or not.\tgetStyle?(cell: Compatible<TCell>, isInEditMode: boolean)\tCellStyle\tReturns custom styles based on cell data applied to the cells div element\tgetClassName?(cell: Compatible<TCell>, isInEditMode: boolean)\tstring\tReturns custom class names based on cell data applied to the cells div element\trender(cell: Compatible<TCell>, isInEditMode: boolean, onCellChanged: (cell: Compatible<TCell>, commit: boolean) => void)\tReact.ReactNode\tRenders cell content"}},"/docs/3.0/7-api/0-interfaces/6a-cell-templates":{"title":"CellTemplates","data":{"":"CellTemplates is an interface describes your custom cell templates as key-value object.\nKey of CellTemplates interface have to be equal to coresponding cell type field (with extends Cell interface).","definition#Definition":"interface CellTemplates {\n    [key: string]: CellTemplate;\n}","example#Example":"const myCellTemplates: CellTemplates = {\n    'flag': FlagCellTemplate,\n    'dropdownNumber': DropdownNumberCellTemplate,\n}\nreturn (\n    <ReactGrid\n      {...props}\n      customCellTemplates={myCellTemplates} // highlight-line\n    />\n);","properties#Properties":"Properties\tType\tProperties description\t[key: string]\tCellTemplate\tType of a cell template and its implementation"}},"/docs/3.0/7-api/0-interfaces/6-cell-location":{"title":"CellLocation","data":{"":"CellLocation is an interface that describes focus position inside the grid.","definition#Definition":"interface CellLocation {\n    readonly rowId: Id;\n    readonly columnId: Id;\n    readonly color?: string;\n}","properties#Properties":"Property name\tType\tProperty description\trowId\tId\tRow of cell to focus\tcolumnId\tId\tColumn of focused cell\tcolor?\tstring\tName of CSS class"}},"/docs/3.0/7-api/0-interfaces/8-menuoption":{"title":"MenuOption","data":{"":"The context menu is part of the grid, each menu option must implement the interface below.","definition#Definition":"interface MenuOption {\n    id: string;\n    label: string;\n    handler: (selectedRowIds: Id[], selectedColIds: Id[], selectionMode: SelectionMode) => void;\n}","properties#Properties":"Property name\tType\tProperty description\tid\tstring\tText that identifies each menu option\tlabel\tstring\tLabel displayed in menu\thandler\t(selectedRowIds: Id[], selectedColIds: Id[], selectionMode: SelectionMode) => void\tFunction that is called when option is clicked"}},"/docs/3.0/7-api/0-interfaces/7-cell-style":{"title":"CellStyle","data":{"":"CellStyle interface prevents passing unwanted CSS properties that could break down grid rendering.","definition#Definition":"interface CellStyle {\n    readonly color?: string;\n    readonly background?: string;\n    readonly overflow?: string;\n    readonly paddingLeft?: string;\n}","properties#Properties":"Property name\tType\tProperty description\tcolor?\tstring\tCSS color property\tbackground?\tstring\tCSS background property\toverflow?\tstring\tCSS overflow property\tpaddingLeft?\tstring\tCSS padding-left property"}},"/docs/3.0/7-api/0-interfaces/9-highlight":{"title":"Highlight","data":{"":"Highlight is an element to mark any cell inside the grid.Highlight (opposed to focus):\nit can be placed on any cell\nit must be managed by a developer unlike 'focus'","definition#Definition":"interface Highlight {\n    readonly rowId: Id;\n    readonly columnId: Id;\n    readonly borderColor?: string;\n    readonly className?: string;\n}","properties#Properties":"Property name\tType\tProperty description\trowId\tId\tRow id of the cell to highlight\tcolumnId\tId\tColumn id of the cell to highlight\tborderColor\tstring\tOptional border color\tclassName\tstring\tOptional CSS classname of the highlighted element"}},"/docs/3.0/7-api/1-types":{"title":"Types","data":{"":"ReactGrid API provides following types:\nCompatible\nCellChange\nUncertain\nUncertainCompatible\nId\nDropPosition\nDefaultCellTypes\nSelectionMode"}},"/docs/3.0/7-api/0-interfaces/90-textlabels":{"title":"TextLabels","data":{"":"TextLabels describes a set of text labels used by ReactGrid.","definition#Definition":"interface TextLabels {\n    legacyBrowserHeader?: string,\n    legacyBrowserText?: string,\n    copyLabel?: string,\n    cutLabel?: string,\n    pasteLabel?: string,\n    macOsContextMenuPasteAlert?: string,\n    otherBrowsersContextMenuPasteAlert?: string,\n    contextMenuPasteAlert?: string\n}","properties#Properties":"Property name\tType\tProperty description\tlegacyBrowserHeader?\tstring\tLabel of text header when browser isn't supported\tlegacyBrowserText?\tstring\tLabel of text paragraph when browser isn't supported\tcopyLabel?\tstring\tLabel of copy action displayed inside context menu (just PRO)\tcutLabel?\tstring\tLabel of cut action displayed inside context menu (just PRO)\tpasteLabel?\tstring\tLabel of paste action displayed inside context menu (just PRO)\tmacOsContextMenuPasteAlert?\tstring\tAlert label in use (e.g., MacOS) if access to the clipboard is denied (just PRO)\totherBrowsersContextMenuPasteAlert?\tstring\tAlert label in use (e.g., Firefox) if access to the clipboard is denied (just PRO)\tcontextMenuPasteAlert?\tstring\tAlert label in use (e.g., Firefox) if access to the clipboard is denied (just PRO)"}},"/docs/3.0/7-api/1-types/1-compatible-cell":{"title":"Compatible","data":{"":"CompatibleCell is an extended and exchangeable cell (compatible with different types).","definition#Definition":"type Compatible<TCell extends Cell> = TCell & {\n    text: string;\n    value: number;\n}","properties#Properties":"Property name\tType\tProperty description\ttext\tstring\tText value of a cell\tvalue\tnumber\tNumeric value of a cell, if there is no numeric value representation use NaN"}},"/docs/3.0/7-api/1-types/2-cell-change":{"title":"CellChange","data":{"":"CellChange type is used by onCellsChanged callback in ReactGrid component. CellChange represents\nmutually exclusive changes to a single cell.CellTypes utility type extracts all possible cell types based on Cell interface.","basic-usage-cases#Basic usage cases":"const handleChangesOnDefaults = (changes: CellChange[]) => { // evaluates as `Change<TextCell> | Change<Datecell> | ...`\n  changes.forEach(change => {\n    if (change.type === 'checkbox') {\n      console.log(change.newCell.checked);\n      console.log(change.initialCell.checked);\n    }\n  });\n};\nconst handleChangesOnDefaultsAndFlagCell = (changes: CellChange<DefaultCellTypes | FlagCell>[]) => { // evaluates as `Change<TextCell> | Change<Datecell> | ... | Change<FlagCell>`\n  changes.forEach(change => {\n    if (change.type === 'flag') {\n      // `FlagCell` specyfic fields are now available\n      console.log(change.newCell.text);\n      console.log(change.initialCell.text);\n    }\n  });\n};\nconst handleChangesOnlyOnDateCell = (changes: CellChange<DateCell>[]) => { // evaluates as `Change<DateCell>`\n  changes.forEach(change => {\n    // only available type is now `date`\n    if (change.type === 'date') {\n      console.log(change.newCell.date);\n      console.log(change.initialCell.date);\n    }\n  });\n};","definition#Definition":"type CellChange<TCell extends Cell = DefaultCellTypes & Cell> = TCell extends Cell ? Change<TCell> : never;\ninterface Change<TCell extends Cell = DefaultCellTypes> {\n    readonly rowId: Id;\n    readonly columnId: Id;\n    readonly type: TCell['type'];\n    readonly initialCell: TCell;\n    readonly newCell: TCell;\n}\nTCell is type that extends common Cell type.\nIt can be one of default cell types or one of yours.\nRead more about creating custom cell templates.","properties#Properties":"Property name\tType\tProperty description\trowId\tId\tRow Id where the change ocurred\tcolumnId\tId\tColumn Id where the change ocurred\ttype\tCellTypes<TCell>\tExtracted cell type of TCell e.g. text, group\tinitialCell\tTCell extends Cell = Cell\tOld content of the cell\tnewCell\tTCell extends Cell = Cell\tNew content of the cell"}},"/docs/3.0/7-api/1-types/2-uncertain-cell":{"title":"Uncertain","data":{"":"Uncertain is a cell type that every field of TCell is optional.\nCell of this type will have only one essential field provided by Cell interface - type.","definition#Definition":"type Uncertain<TCell extends Cell> = Partial<TCell> & Cell;"}},"/docs/3.0/7-api/1-types/4-id":{"title":"Id","data":{"":"Id is a common type to identify many objects in grid e.g.:\nHighlight,\nCellLocation,\nCellChange,\nColumn,\nRow\nId can be a number or string.","definition#Definition":"type Id = number | string;"}},"/docs/3.0/7-api/1-types/3-uncertain-compatible-cell":{"title":"UncertainCompatible","data":{"":"UncertainCompatible is a cell type that is compatible with other cell types\nthat can be instances of various cell types (e.g. DataCell and TimeCell).","definition#Definition":"type UncertainCompatible<TCell extends Cell> = Uncertain<TCell> & {\n    text: string;\n    value: number;\n}"}},"/docs/3.0/7-api/1-types/5-drop-position":{"title":"DropPosition","data":{"":"Indicates where row/column was dropped. Used by ReactGridProps callbacks.","definition#Definition":"type DropPosition = 'before' | 'on' | 'after';"}},"/docs/3.0/7-api/1-types/6-default-cells":{"title":"DefaultCellTypes","data":{"":"ReactGrid API contains a union of basic cells usually used for consuming changes and\nmarking cells array inside the data row.","definition#Definition":"type DefaultCellTypes = CheckboxCell | DateCell | EmailCell | GroupCell | HeaderCell | NumberCell | TextCell | TimeCell;"}},"/docs/3.0/7-api/1-types/7-selection-mode":{"title":"Selection mode","data":{"":"ReactGrid API contains three types of values which can be used in selection. It is row, column or range.","definition#Definition":"type SelectionMode = 'row' | 'column' | 'range';"}},"/docs/3.1":{"title":"3.1","data":{"":"ReactGrid lets you create custom data grids inside your ReactJS applications, which look and feel like spreadsheets.","caveats#Caveats":"a) If you notice sticky incorrect behavior, when you try to pin them to HTML <body> tag, add this line to index.html file in your project.\nIt should be helpful in many cases and different mobile devices.\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=0.86, maximum-scale=5.0, minimum-scale=0.86\">","supported-browsers#Supported browsers":"Desktop Browsers\nMobile Browsers"}},"/docs/3.0/7-api/2-functions":{"title":"Functions & Enums","data":{"keycodes#Keycodes":"Keycode related functions are commonly used by every cell template and they uses the unicode value of pressed keyboard key\n(exacly like KeyboardEvent.keyCode).\nisAlphaNumericKey(keyCode: number): boolean\nUsed in creating custom cell templates. Checks if keycode is alphanumeric.\ninNumericKey(keyCode: number): boolean\nUsed in creating custom cell templates. Checks if keycode is between 0 and 9 (also on numpad).\nisNumpadNumericKey(keyCode: number): boolean\nUsed in creating custom cell templates. Checks if keycode is between 0 and 9 on numpad.\nisAllowedOnNumberTypingKey(keyCode: number): boolean\nUsed in creating custom cell templates. Checks if keycode is allowed while typing\nnumbers (for chars like comma, dash, period).\nisNavigationKey(keyCode: number): boolean\nUsed in creating custom cell templates. Checks if keycode is allowed for navigation\n(arrows, end, home, backspace, delete keys).\ngetCharFromKeyCode(keyCode: number, isShiftKey: boolean = false): boolean\nConverts key code into char including the Shift key.","helpers#Helpers":"getCellProperty = <TCell extends Cell, TKey extends keyof TCell>(\n    uncertainCell: Uncertain<TCell>,\n    propName: TKey,\n    expectedType: 'string' | 'number' | 'boolean' | 'undefined' | 'function' | 'object' | string\n)\nReturns cell property value. Used to create a compatible cell.","enums#Enums":"keyCodes enum contains a set of key codes + POINTER = 1 to mark a pointer event (ReactGrid addon).\nUsed in cell templates."}},"/docs/3.1/1-getting-started":{"title":"Getting started","data":{"introduction#Introduction":"In this guide, we're going to build a very simple React App, which will make use of ReactGrid.","initialize-a-react-app-with-reactgrid#Initialize a React App with ReactGrid":"Let's create the basis for our App first:\nnpx create-react-app reactgrid-getting-started --typescript\ncd reactgrid-getting-started\nThe only thing that's missing from our project now is ReactGrid itself.\nTo add it to the dependencies, simply run:\nnpm install @silevis/reactgrid","integrate-reactgrid-into-the-app#Integrate ReactGrid into the App":"Once ReactGrid is installed and ready, we can import it in the following way:\n// App.tsx\nimport * as React from \"react\";\nimport { render } from \"react-dom\";\nimport { ReactGrid, Column, Row } from \"@silevis/reactgrid\";\nimport \"@silevis/reactgrid/styles.css\";\nOur example requires ReactGrid component, two interfaces: Column,\nRow from @silevis/reactgrid and CSS styles from @silevis/reactgrid/styles.css.","define-some-data-to-display-in-the-grid#Define some data to display in the grid":"Although we were able to create an empty ReactGrid, it wouldn't make much sense yet.\nSo let's define some data first, and then feed it into ReactGrid for display.\nWe're going to need two arrays. One for columns prop,\nand the other for rows.\nAt the top of the datatable we are going to display static cells that contain Name and Surname so we can define them now.\nDon't worry about all the properties of columns\nand rows objects now - we'll cover them later on.\ninterface Person {\n  name: string;\n  surname: string;\n}\nconst getPeople = (): Person[] => [\n  { name: \"Thomas\", surname: \"Goldman\" },\n  { name: \"Susie\", surname: \"Quattro\" },\n  { name: \"\", surname: \"\" }\n];\nconst getColumns = (): Column[] => [\n  { columnId: \"name\", width: 150 },\n  { columnId: \"surname\", width: 150 }\n];\nconst headerRow: Row = {\n  rowId: \"header\",\n  cells: [\n    { type: \"header\", text: \"Name\" },\n    { type: \"header\", text: \"Surname\" }\n  ]\n};","generate-your-rows#Generate your rows":"ReactGrid rows prop expects an array of rows that are compatible with imported\nrowss interface.\nAs you see this function returns the header row and mapped people array to ReactGrid's\nRows.\nconst getRows = (people: Person[]): Row[] => [\n  headerRow,\n  ...people.map<Row>((person, idx) => ({\n    rowId: idx,\n    cells: [\n      { type: \"text\", text: person.name },\n      { type: \"text\", text: person.surname }\n    ]\n  }))\n];","pass-the-data-to-reactgrid#Pass the data to ReactGrid":"We've got everything we need to see ReactGrid in action.\nIt's finally time to use the ReactGrid component we imported earlier, and give it the data\nwe defined in the previous steps. This is easy, and can be done like that:\nfunction App() {\n  const [people] = React.useState<Person[]>(getPeople());\n  const rows = getRows(people);\n  return <ReactGrid rows={rows} columns={columns} />;\n}","putting-it-all-together#Putting it all together":"After having followed this guide, your App.tsx file should look more or less like this:\nimport * as React from \"react\";\nimport { render } from \"react-dom\";\nimport { ReactGrid, Column, Row } from \"@silevis/reactgrid\";\nimport \"@silevis/reactgrid/styles.css\";\nimport \"./styles.css\";\ninterface Person {\n  name: string;\n  surname: string;\n}\nconst getPeople = (): Person[] => [\n  { name: \"Thomas\", surname: \"Goldman\" },\n  { name: \"Susie\", surname: \"Quattro\" },\n  { name: \"\", surname: \"\" }\n];\nconst getColumns = (): Column[] => [\n  { columnId: \"name\", width: 150 },\n  { columnId: \"surname\", width: 150 }\n];\nconst headerRow: Row = {\n  rowId: \"header\",\n  cells: [\n    { type: \"header\", text: \"Name\" },\n    { type: \"header\", text: \"Surname\" }\n  ]\n};\nconst getRows = (people: Person[]): Row[] => [\n  headerRow,\n  ...people.map<Row>((person, idx) => ({\n    rowId: idx,\n    cells: [\n      { type: \"text\", text: person.name },\n      { type: \"text\", text: person.surname }\n    ]\n  }))\n];\nfunction App() {\n  const [people] = React.useState<Person[]>(getPeople());\n  const rows = getRows(people);\n  const columns = getColumns();\n  return <ReactGrid rows={rows} columns={columns} />;\n}\nrender(<App />, document.getElementById(\"root\"));\nYou can now start the App locally with:\nnpm start\nOr simply play around with the interactive demo below:","summary#Summary":"You should now have a basic understanding of what ReactGrid is and how it can be used.\nContinue to the next page for more advanced usage examples."}},"/docs/3.1/2-implementing-core-features":{"title":"Implementing core features","data":{"":"In this section you will learn about common features of ReactGrid and their example implementations.\nHandling data changes\nColumn resizing\nColumn and row reordering\nSticky rows and columns\nSelections\nFill handle\nContext menu\nGroup Id\nHighlights\nGrouping\nManaging focus\nEmbedding on website\nKeyboard shortcuts\nUndo / Redo feature\nFull width header\nInternationalization\nResponsive sticky headers\nColspan and rowspan cell"}},"/docs/3.1/2-implementing-core-features/1-handling-changes":{"title":"Handling data changes","data":{"idea-of-handling-data-changes#Idea of handling data changes":"A user changes the value of a cell. Among others, it could mean that the user has:\ncommitted a new value into a cell by cell editor,\nused a fill handle,\npasted some data into the cell matrix,\ninteracted with a clickable cell (e. g. expanded chevron cell).\nReactGrid fires the onCellsChanged event\nYour handler function processes the event and updates the data\nThe ReactGrid component receives new data and gets rerendered\nBy default, the data grid will behave as if it was in a \"read-only\" mode.\nTo support dynamic data editing, you will have to handle the onCellsChanged event yourself.","when-is-my-handler-function-called#When is my handler function called?":"Changes have been committed after cell editing.\nAfter pasting with the shortcut or the context menu.\nAfter fill handle action.","handling-changes-in-your-project#Handling changes in your project":"This part is based on getting started.Let's start with updating imports:\nimport {\n  ReactGrid,\n  Column,\n  Row,\n  CellChange,\n  TextCell,\n} from \"@silevis/reactgrid-3.1\";","sample-change-handler-function#Sample change handler function":"The function receives an array describing all of the changes made to the data grid's cells and data on the basis of which\nReactGrid's rows were generated.\nWe expect that the incoming changes affect TextCell, so the changes were marked by a following interface: CellChange<TextCell>[].\nGiven that information, we find the row and the column affected by each change,\nand then replace an appropriate cell text with a new one.\nWe can declare a basic handler function like this:\nconst applyChangesToPeople = (\n  changes: CellChange<TextCell>[],\n  prevPeople: Person[]\n): Person[] => {\n  changes.forEach((change) => {\n    const personIndex = change.rowId;\n    const fieldName = change.columnId;\n    prevPeople[personIndex][fieldName] = change.newCell.text;\n  });\n  return [...prevPeople];\n};\nLet's pass the handler function to our ReactGrid component:\nfunction App() {\n  const [people, setPeople] = React.useState<Person[]>(getPeople());\n  const rows = getRows(people);\n  const columns = getColumns();\n  const handleChanges = (changes: CellChange<TextCell>[]) => {\n    setPeople((prevPeople) => applyChangesToPeople(changes, prevPeople));\n  };\n  return (\n    <ReactGrid rows={rows} columns={columns} onCellsChanged={handleChanges} />\n  );\n}"}},"/docs/3.1/2-implementing-core-features/2-column-resizing":{"title":"Column resizing","data":{"":"This feature is only available in PRO version","allow-column-to-be-resized#Allow column to be resized":"For each column which should be resizable, add the resizable property\nto the corresponding column object and set its value to true.\nconst getColumns = (): Column[] => [\n    { columnId: \"name\", width: 150, resizable: true }, //highlight-line\n    { columnId: \"surname\", width: 150, resizable: true } //highlight-line\n];\nIf you hover over the vertical border line between the column headers,\nyou will see your mouse pointer change to indicate that a column can be resized.\nHowever, you'll quickly notice that the column resizing functionality doesn't work.\nWhy is that? We still need to handle the events fired by ReactGrid when a column is being resized.\nSimilar to how we handled data changes in handling changes,\nwe can also define a handler function for that and pass it to our ReactGrid component.","usestate-hook-for-columns-storing#useState hook for columns storing":"function App() {\n    const [people] = React.useState<Person[]>(getPeople());\n    const [columns, setColumns] = React.useState<Column[]>(getColumns()); //highlight-line\n    const rows = getRows(people);\n    return <ReactGrid rows={rows} columns={columns} />;\n}","implement-the-handler-function#Implement the handler function":"handleColumnResize handles the event when its finished. Knowing the column Id and its new width, we can apply\nchanges by calling setColumns function and returning array of updated columns (width/widths).\nfunction App() {\n    const [people] = React.useState<Person[]>(getPeople());\n    const [columns, setColumns] = React.useState<Column[]>(getColumns());\n    const rows = getRows(people);\n    const handleColumnResize = (ci: Id, width: number) => {\n        setColumns((prevColumns) => {\n            const columnIndex = prevColumns.findIndex(el => el.columnId === ci);\n            const resizedColumn = prevColumns[columnIndex];\n            const updatedColumn = { ...resizedColumn, width };\n            prevColumns[columnIndex] = updatedColumn;\n            return [...prevColumns];\n        });\n    }\n    return <ReactGrid rows={rows} columns={columns} onColumnResized={handleColumnResize} />;\n}","live-demo#Live demo":"Let's check the results:"}},"/docs/3.1/2-implementing-core-features/3-column-and-row-reordering":{"title":"Column and row reordering","data":{"how-to-implement-column-and-row-reordering#How to implement column and row reordering?":"This feature is only available in PRO version\nThis guide is based on getting started.","1-update-person-interface-and-people-data#1. Update person interface and people data":"Our Person interface will be extended with the id field. It's necessary to identify person to keep correct order after\nrow reorder action.\ninterface Person {\n  id: number;\n  name: string;\n  surname: string;\n}\nconst getPeople = (): Person[] => [\n  { id: 1, name: \"Thomas\", surname: \"Goldman\" },\n  { id: 2, name: \"Susie\", surname: \"Quattro\" },\n  { id: 3, name: \"\", surname: \"\" }\n];","2-update-column-related-properties#2. Update column related properties":"In our example we will be able to see how to reorder two declared columns.\nWe are currenly working with a column whose application we know everything about.\nLet's define coresponding interface that is personalized stricly to our needs.\ninterface ColumnMap {\n  name: 'Name';\n  surname: 'Surname';\n}\nconst columnMap: ColumnMap = {\n  name: 'Name',\n  surname: 'Surname'\n};\nReactGrid's Column interface contains columnId property. You can assign any string or even numberto this property.\nIn this example we know that we are working with only name and surname as so we can augment Column\ninterface definition by doing this:\ntype ColumnId = keyof ColumnMap;","3-make-your-columns-reorderable#3. Make your columns reorderable":"This step is simple - just add reorderable: true to the column definitions.\nconst getColumns = (): Column[] => [\n  { columnId: 'name', width: 150, reorderable: true }, // highlight-line\n  { columnId: 'surname', width: 200, reorderable: true } // highlight-line\n];","4-display-rows-with-arbitrary-columns-order#4. Display rows with arbitrary columns order":"In Relation to the base example we need to add one mode argument: columnsOrder.\nThis parameter contains columns key (name or surname) in the same order as we want to display people.\nWe also moved headerRow and replaced it with an object to get a corresponding column title and value of columnMap.\nAlso cells inside mapped people array select persons' attributes in accordance with the order of columns.\nconst getRows = (people: Person[], columnsOrder: ColumnId[]): Row[] => {\n  return [\n    {\n      rowId: \"header\",\n      cells: [\n        { type: \"header\", text: columnMap[columnsOrder[0]] },\n        { type: \"header\", text: columnMap[columnsOrder[1]] }\n      ]\n    },\n    ...people.map<Row>((person, idx) => ({\n      rowId: person.id,\n      reorderable: true,\n      cells: [\n        { type: \"text\", text: person[columnsOrder[0]] }, // `person['name']` / `person['surname']`\n        { type: \"text\", text: person[columnsOrder[1]] } // `person['surname']` / `person['name']`\n      ]\n    }))\n  ]\n};\nreorderArray function is used to order columns or rows. You can just copy it.\n// a helper function used to reorder arbitrary arrays\nconst reorderArray = <T extends {}>(arr: T[], idxs: number[], to: number) => {\n    const movedElements = arr.filter((_, idx) => idxs.includes(idx));\n    const targetIdx = Math.min(...idxs) < to ? to += 1 : to -= idxs.filter(idx => idx < to).length;\n    const leftSide = arr.filter((_, idx) => idx < targetIdx && !idxs.includes(idx));\n    const rightSide = arr.filter((_, idx) => idx >= targetIdx && !idxs.includes(idx));\n    return [...leftSide, ...movedElements, ...rightSide];\n}","5--implement-column-and-row-handlers#5.  Implement column and row handlers":"All that remains to write is handler for rows and column reordering.\nColumn and row reorder handler is based on searching for destination target index and mapping reordered items to array\nof their occurrence. After that we pass previously mentioned indexes to reorderArray function and update data by calling\nsetColumns and setPeople.\nReactGrid component needs to have enabled enableRowSelection and enableColumnSelection.\nconst ColumnsAndRowsReorderSample = () => {\n    const [people, setPeople] = React.useState<Person[]>(getPeople());\n    const [columns, setColumns] = React.useState<Column[]>(getColumns());\n    const rows = getRows(people, columns.map(c => c.columnId as ColumnId));\n    const handleColumnsReorder = (targetColumnId: Id, columnIds: Id[]) => {\n        const to = columns.findIndex((column) => column.columnId === targetColumnId);\n        const columnIdxs = columnIds.map((columnId) => columns.findIndex((c) => c.columnId === columnId));\n        setColumns(prevColumns => reorderArray(prevColumns, columnIdxs, to));\n    }\n    const handleRowsReorder = (targetRowId: Id, rowIds: Id[]) => {\n        setPeople((prevPeople) => {\n            const to = people.findIndex(person => person.id === targetRowId);\n            const rowsIds = rowIds.map((id) => people.findIndex(person => person.id === id));\n            return reorderArray(prevPeople, rowsIds, to);\n        });\n    }\n    return <ReactGrid\n        rows={rows}\n        columns={columns}\n        onColumnsReordered={handleColumnsReorder}\n        onRowsReordered={handleRowsReorder}\n        enableRowSelection\n        enableColumnSelection\n    />;\n}","bonus---preventing-dropping-rows-on-unwanted-location#Bonus - preventing dropping rows on unwanted location":"This 'feature' can be done by making handleCanReorderRows function and passing it to canReorderRows ReactGrid prop.\nWe also provided canReorderColumns prop that can do the same thing, but with columns.While you reorder a row you can see the line that is visible above the  header row. We probably don't want to mislead the end user\nwho might drop the row over there.When you drop row then your handleCanReorderRows is called. We can define that dropping over the row whose rowId field equals\nheader is prohibited. In this case you won't see reorder line indication and handleRowsReorder is not called by default.\nconst handleCanReorderRows = (targetRowId: Id, rowIds: Id[]): boolean => {\n    return targetRowId !== 'header';\n}\nconst ColumnsAndRowsReorderSample = () => {\n   // ...\n    return <ReactGrid\n        rows={rows}\n        columns={columns}\n        onColumnsReordered={handleColumnsReorder}\n        onRowsReordered={handleRowsReorder}\n        enableRowSelection\n        enableColumnSelection\n        canReorderRows={handleCanReorderRows} // highlight-line\n    />;\n}","live-demo#Live demo":""}},"/docs/3.1/2-implementing-core-features/4-sticky":{"title":"Sticky rows and columns","data":{"introduction#Introduction":"ReactGrid allows you to stick chosen rows and columns at the top or left side and additionally on the right and at the bottom\nof the ReactGrid viewport only in PRO version. Sticky rows or columns will be visible at all times, no matter what the scroll position is.\nRight and bottom sticky ranges are only available in PRO version\nSticky rows and columns can be enabled by adding dedicated ReactGrid component properties:\nstickyTopRows\nstickyBottomRows\nstickyLeftColumns\nstickyRightColumns\nAll of these properties are numeric and determine the number of columns or rows sticky next to the grid's edges.","how-to-make-columns-and-rows-sticky#How to make columns and rows sticky?":"This guide is based on getting started.\nUpdate Person interface and then add some more data to the table, so that it's more likely for a scrollbar to appear\nor reduce the height of the grid container.\ninterface Person {\n    name: string;\n    surname: string;\n    birth: Date | undefined; // highlight-line\n    mobile: number; // highlight-line\n    company: string; // highlight-line\n    occupation: string; // highlight-line\n}\nconst getPeople = (): Person[] => [\n    {\n        name: \"Thomas\",\n        surname: \"Goldman\",\n        birth: new Date(\"1970-12-02\"), // highlight-line\n        mobile: 574839457, // highlight-line\n        company: \"Snatia Ebereum\", // highlight-line\n        occupation: \"CEO\" // highlight-line\n    },\n    {\n        name: \"Mathew Lawrence\",\n        surname: \"Joshua\",\n        birth: new Date(\"1943-12-02\"), // highlight-line\n        mobile: 684739283, // highlight-line\n        company: \"De-Jaiz Mens Clothing\", // highlight-line\n        occupation: \"Technical recruiter\" // highlight-line\n    },\n    {\n        name: \"Susie Evelyn\",\n        surname: \"Spencer\",\n        birth: new Date(\"1976-01-23\"), // highlight-line\n        mobile: 684739283, // highlight-line\n        company: \"Harold Powell\", // highlight-line\n        occupation: \"Concrete paving machine operator\" // highlight-line\n    },\n    {\n        name: \"\",\n        surname: \"\",\n        birth: undefined, // highlight-line\n        mobile: NaN, // highlight-line\n        company: \"\", // highlight-line\n        occupation: \"\" // highlight-line\n    }\n];\nconst getColumns = (): Column[] => [\n    { columnId: \"Name\", width: 150 },\n    { columnId: \"Surname\", width: 100 },\n    { columnId: \"Birth Data\", width: 100 }, // highlight-line\n    { columnId: \"Phone\", width: 100 }, // highlight-line\n    { columnId: \"Company\", width: 150 }, // highlight-line\n    { columnId: \"Occupation\", width: 230 } // highlight-line\n];\nUse the properties mentioned in the introduction to set the number of sticky ranges at each edge\nreturn (\n\t<ReactGrid\n\t\trows={rows}\n\t\tcolumns={columns}\n\t\tstickyLeftColumns={1} // highlight-line\n\t\tstickyRightColumns={1} // highlight-line\n\t\tstickyTopRows={1} // highlight-line\n\t\tstickyBottomRows={1} // highlight-line\n\t/>\n);","result#Result":"Here's how sticky rows and columns look in action (we recommend playing with this demo in the fullscreen mode):"}},"/docs/3.1/2-implementing-core-features/4b-fill-handle":{"title":"Fill handle","data":{"":"This feature is only available in PRO version\nReactGrid supports fill handle action in PRO version, but it is disabled by default. To turn it on you have to simply\nadd enableFillHandle property to ReactGrid component. Now you are able to use autocomplete feature by default.\nThis feature allows you to set further values to be filled in based on the data contained in the selection. Otherwise, the data is repeated\nrespective to the direction. Data isn't predicted when ctrl key is pressed (or Option/⌥ key on Apple devices).\n<ReactGrid\n    {...props}\n    enableFillHandle //highlight-line\n/>\nNote that if an incoming change will not be handled by the app, then there will be no visible changes,\nthough the action was correctly performed."}},"/docs/3.1/2-implementing-core-features/4a-selections":{"title":"Selections","data":{"":"This feature is only available in PRO version\nReactGrid has three properties related to selections inside the grid via ReactGrid:\nenableRangeSelection\nenableRowSelection\nenableColumnSelection","enablerangeselection-property#enableRangeSelection property":"The range selection is the most common selection, but in case you want to use it, it's necessary to enable it before.\nYou can do multiple selections by holding the Ctrl or Command ⌘ key on Apple devices.\n<ReactGrid\n    {...props}\n    enableRangeSelection //highlight-line\n/>","enablerowselection-and-enablecolumnselection-property#enableRowSelection and enableColumnSelection property":"Way how enableRowSelection and enableColumnSelection property works is very similar.When you first click on:\nthe left cell of a row, the whole row will be selected, then you can expand this selection to other rows;\nthe top cell of the column, the whole column will be selected, then you can expand this selection to other columns.\nYou can then select or unselect any row/column by Ctrl or Command ⌘ key.If you click on the first top-left cell and enableColumnSelection is enabled then the column has a priority\nover the row in this particular case.\n<ReactGrid\n    {...props}\n    enableRowSelection //highlight-line\n    enableColumnSelection //highlight-line\n/>"}},"/docs/3.1/2-implementing-core-features/5-context-menu":{"title":"Context menu","data":{"":"Context menu is only available in PRO version\nReactGrid comes with a custom context menu feature. Custom menu entries can be easily created thus\nallowing for personalized experiences.\nBy default, the context menu is disabled. You can enable it by providing a handler function\nto your ReactGrid using the onContextMenu property.","enabling-simple-context-menu#Enabling simple context menu":"This guide is based on handling data changes.\nUpdate imports by adding Id, SelectionMode\nand MenuOption interfaces.\nimport { ReactGrid, CellChange, Row, Column, Id, MenuOption, SelectionMode } from \"@silevis/reactgrid\";\nImplement the context menu handler function\nThe menuOptions argument of simpleHandleContextMenu contains a list of default menu entries\nprovided by ReactGrid - copy, cut and paste.\nFor now, we'll simply define it, which will enable the default ReactGrid context menu.\nconst [people, setPeople] = React.useState<Person[]>(getPeople());\n  const rows = getRows(people);\n  const columns = getColumns();\n  const handleChanges = (changes: CellChange[]) => {\n    setPeople((prevPeople) => applyChangesToPeople(changes, prevPeople));\n  };\n  const simpleHandleContextMenu = (\n    selectedRowIds: Id[],\n    selectedColIds: Id[],\n    selectionMode: SelectionMode,\n    menuOptions: MenuOption[]\n  ): MenuOption[] => {\n    return menuOptions;\n  }\n  return (\n    <ReactGrid\n      rows={rows}\n      columns={columns}\n      onCellsChanged={handleChanges}\n      onContextMenu={simpleHandleContextMenu}\n    />\n  );\nHere's the result. Right-click anywhere in the grid to see the context menu.","advanced-example---removing-columns-and-rows#Advanced example - removing columns and rows":"The default menu, though pretty, may seem a bit lacklustre when it comes to the functionality it provides.\nLet's try and extend it a bit - we'll make it possible to remove people using the context menu.\nImplement a more advanced context menu handler function.\nconst handleContextMenu = (\n  selectedRowIds: Id[],\n  selectedColIds: Id[],\n  selectionMode: SelectionMode,\n  menuOptions: MenuOption[]\n): MenuOption[] => {\n  if (selectionMode === \"row\") {\n    menuOptions = [\n      ...menuOptions,\n      {\n        id: \"removePerson\",\n        label: \"Remove person\",\n        handler: () => {\n          setPeople(prevPeople => {\n            return [...prevPeople.filter((person, idx) => !selectedRowIds.includes(idx))]\n          })\n        }\n      }\n    ];\n  }\n  return menuOptions;\n}\nUpdate the ReactGrid component's properties. Note that rows must be selectable for our feature to work.\nAfter all, we will be removing the currently selected rows.\nreturn (\n  <ReactGrid\n    rows={rows}\n    columns={columns}\n    onCellsChanged={handleChanges}\n    onContextMenu={handleContextMenu}\n    enableFillHandle\n    enableRangeSelection\n    enableRowSelection\n  />\n)","live-demo#Live demo":"You can see the effect of the changes we've just introduced in the demo below.\nTo test the new feature, simply select a row by clicking a header cell or one of the leftmost cells,\nthen right-click anywhere and use the new menu entry."}},"/docs/3.1/2-implementing-core-features/6-highlights":{"title":"Highlights","data":{"highlights-usage#Highlights usage":"This guide is based on getting started.Highlights allow you to alter arbitrary cells in the grid\nby applying custom CSS classes to them or by setting their border colours.\nImport the Highlight interface\nimport { ReactGrid, Highlight } from \"@silevis/reactgrid\";\nDefine an array of Highlight objects\nconst highlights: Highlight[] = [\n  { columnId: \"Name\", rowId: 1, borderColor: \"#00ff00\" },\n  { columnId: \"Surname\", rowId: 2, borderColor: \"#0000ff\" },\n  { columnId: \"Name\", rowId: 3, borderColor: \"#ff0000\" }\n];\nPass the highlights object array to your component\nreturn <ReactGrid rows={rows} columns={columns} highlights={highlights} />;","live-demo#Live demo":""}},"/docs/3.1/2-implementing-core-features/5a-groupId":{"title":"Group Id","data":{"":"ReactGrid introduces a brand new feature called group Id. The main purpose of it is to avoid queueing changes\nby marking cells on groupId property using Id interface.Marked cell with a groupId has a following behavior. While you paste data or execute fill handle action: the change will\nbe queued only for a cell with the same groupId. If the change can't be queued, then you will be warned in browser's console.\nEven if no cell is marked, then they are treated as a separate group.Every cell with declared groupId renders with additional span element (containing its value) inside a cell if\nyou have passed enableGroupIdRender property:\n<ReactGrid\n    {...props}\n    enableFillHandle\n    enableRangeSelection\n    enableGroupIdRender // highlight-line\n/>\ngroupId property is available in every cell template because it's provided by Cell\ninterface.","live-example#Live example":"An example shows that a few cells were marked with group: A or group: B group Id.\nTry and select any range and then copy and paste or use fill handle to clone data."}},"/docs/3.1/2-implementing-core-features/7-managing-focus":{"title":"Focus management","data":{"focus-locations#Focus locations":"ReactGrid has two properties related to focus location inside the grid via ReactGrid:\nfocusLocation\ninitialFocusLocation","initialfocuslocation-property#initialFocusLocation property":"You can set focus location at the first render of ReactGrid. Then this property is used no more.\n<ReactGrid\n    {...props}\n    initialFocusLocation={{ columnId: 'col-2', rowId: 'row-2' }} //highlight-line\n/>","focuslocation-property#focusLocation property":"Defining focusLocation property is superior to pointer and keyboard actions, so you have to manage it all over time.\nIf focusLocation property has falsy value then it is ignored.\nDefined initialFocusLocation is immediately overridden by focusLocation\n<ReactGrid\n    {...props}\n    initialFocusLocation={{ columnId: 'col-3', rowId: 'row-3' }} //highlight-line\n    focusLocation={{ columnId: 'col-2', rowId: 'row-2' }} //highlight-line\n/>"}},"/docs/3.1/2-implementing-core-features/9b-full-width-header":{"title":"Full width header","data":{"introduction#Introduction":"Full width header feature is experimental and it can be changed in the future\nThis feature extends width of top sticky pane to full available space inside ReactGrid's parent.","usage#Usage":"Add enableFullWidthHeader property to ReactGrid component and add any number of stickyTopRows. In our example, the sample\nReactGrid component was also wrapped inside a div element that is wider than all columns.\nreturn (\n  <div style={{ width: \"1200px\", height: \"200px\" }}>\n    <ReactGrid\n      rows={rows}\n      columns={columns}\n      enableFullWidthHeader\n      stickyTopRows={1}\n    />\n  </div>\n);","#":"","issues#Issues":"If the width of ReactGrid's parent is less then the sum of all the columns (including left sticky), there might be bugs\nenabling right and bottom sticky panes can cause bugs related with scrolling, ranges selection etc."}},"/docs/3.1/2-implementing-core-features/9-keyboard-shortcuts":{"title":"Keyboard shortcuts","data":{"":"Some of the available shortcuts are related with only PRO functionality","about-keyboard-events#About keyboard events":"ReactGrid allows you to interact with the grid using keyboard shortcuts in a way known from other spreadsheet-like apps.At this moment we plan to add few callback events for clipboard action like copying, pasting and cutting.","keyboard-shortcuts#Keyboard shortcuts":"Shortcut\tAction\t↑\tMoves cell focus one cell up (if is focusable)\t↓\tMoves cell focus one cell down (if is focusable)\t←\tMoves cell focus to the left (if is focusable)\t→\tMoves cell focus to the right (if is focusable)\tEnter\tOpens cell editor if cell is focused or moves focus down inside range selection\tDelete or Backspace\tWipe selected range or only focused location\tTab\tMoves focus to the right if single cell is selected or moves focus to the right inside range selection\tHome\tMoves focus to the first column\tEnd\tMoves focus to the last column\tPageUp\tMoves focus up by one page (visible number of rows)\tPageDown\tMoves focus down by one page (visible number of rows)\tEscape\tAborts cell edition without changing it\tCtrl + Space\tExpands selection in vertical direction (only on Apple devices)\tCtrl  + Shift + Home or  ⌘ + Shift + Home\tSelects all cells above currect selection\tCtrl + Shift + End or  ⌘ + Shift +  End\tSelects all cells below currect selection\t⌘ + A or Ctrl + A\tSelects all cells\t⌘ + Home or Ctrl + Home\tSelects top left cell\t⌘ + End or Ctrl + End\tSelects bottom right cell\tCtrl + End\tSelect whole column on Windows\tShift + Enter\tCloses cell editor if it is opened and moves focus cell above last edited cell\tShift + ↑\tSelects one cell above\tShift + ↓\tSelects one cell below\tShift + ←\tSelects one cell on the left\tShift + →\tSelects one cell on the right\tShift + Tab\tMoves focus to the left if single cell is selected or moves focus to the left inside range selection\tShift + Enter\tMoves focus one cell above if single cell is selected or moves focus up inside range selection\tShift + Space\tExpands selection in vertical direction (from top to bottom)\tShift + Home\tExpands selection to the first column\tShift + End\tExpands selection to the last column\tShift + PageUp\tIncrease or decrease selection by single page\tShift + PageDown\tIncrease or decrease selection by single page"}},"/docs/3.1/2-implementing-core-features/8-embedding-on-website":{"title":"Embedding on a website","data":{"about-reactgrig-embedding-virtual-scrolling-and-sticky-panes-pinning#About ReactGrig embedding, virtual scrolling and sticky panes pinning":"ReactGrid component isn't limited by height and width so its behaviour can change a little bit depending on its scrollable parent element.ReactGrid appends scroll event to its immediate scrollable parent and lets itself expand to full height/width with the option of\nconstant observation of available viewport size.Limiting the size of ReactGrid can be achieved by adding CSS class listed below\n(bear in mind that the total rows height must be bigger than scrollable element height)\n.reactgrid-wrapper {\n    height: 100px;\n    overflow: scroll;\n}\nMultiple nested scrollable elements can cause unexpected experience like incorrect cell editor position, wrong focus location etc.\nIf all rows/columns can't be rendered in viewport - virtual scrolling still works fine.","example-reactgrid-component-limited-by-the-height-of-its-parent#Example: ReactGrid component limited by the height of its parent":"In this case, not all the passed rows can be rendered, so scrollbar appears and sticky pane is pinned directly to the top of the\nparent element.","example-reactgrid-component-not-limited-by-the-height-of-its-parent#Example: ReactGrid component NOT limited by the height of its parent":"ReactGrid renders all the passed rows and columns if sticky panes are passed - they are pinned directly to the edge\nof body element."}},"/docs/3.1/2-implementing-core-features/9a-undo-redo-feature":{"title":"Undo/redo feature","data":{"idea-of-undoredo-feature#Idea of Undo/redo feature":"An Undo/Redo feature isn't implemented internally, but we prepared an example which you can follow.\nReactGrid bypasses undo and redo events.\nYou can handle onKeyDown event to use your own implemented Undo/Redo feature.\nThe ReactGrid component receives revoked or restored data and gets rerendered.\nIt's possible to use with Ctrl + z and Ctrl + y keyboard shortcuts or prepared by you buttons.","when-are-my-handler-functions-called#When are my handler functions called?":"Changes have been committed after Ctrl + z and Ctrl + y key.\nChanges have been committed after Undo and Redo button.","implementing-feature-in-your-project#Implementing feature in your project":"This feature develops handling changes example.Let's start with updating imports:\nimport {\n  ReactGrid,\n  Column,\n  Row,\n  CellChange,\n  TextCell,\n} from \"@silevis/reactgrid\";","sample-undoredo-feature#Sample Undo/Redo feature":"For this reason we prepared special functions, which you can use in your project and adjust to it.\nWe have an array of changes made by the user at each step. The place in the history of changes, where you currently are, is stored.\nLook at this function:\nconst applyNewValue = (\n  changes: CellChange<TextCell>[],\n  prevPeople: Person[],\n  usePrevValue: boolean = false\n): Person[] => {\n  changes.forEach((change) => {\n    const personIndex = change.rowId;\n    const fieldName = change.columnId;\n    const cell = usePrevValue ? change.previousCell : change.newCell;\n    prevPeople[personIndex][fieldName] = cell.text;\n  });\n  return [...prevPeople];\n};\nFunction applyChangesToPeople is a similar function which is responsible for handling changes.\nAdditionally we need to store all the changes and the index of changes, which will help us to move within the changes array.\nconst applyChangesToPeople = (\n  changes: CellChange<TextCell>[],\n  prevPeople: Person[]\n): Person[] => {\n  const updated = applyNewValue(changes, prevPeople);\n  setCellChanges([...cellChanges.slice(0, cellChangesIndex + 1), changes]);\n  setCellChangesIndex(cellChangesIndex + 1);\n  return updated;\n};\nThe undoChanges function allows you to set the previous value and change the index in the appropriate place in the array.\nThe change index is moved one step backwards.\nconst undoChanges = (\n  changes: CellChange<TextCell>[],\n  prevPeople: Person[]\n): Person[] => {\n  const updated = applyNewValue(changes, prevPeople, true);\n  setCellChangesIndex(cellChangesIndex - 1);\n  return updated;\n};\nThe redoChanges function allows you to set the restored change. Change index also has to be moved one position forward.\nconst redoChanges = (\n  changes: CellChange<TextCell>[],\n  prevPeople: Person[]\n): Person[] => {\n  const updated = applyNewValue(changes, prevPeople);\n  setCellChangesIndex(cellChangesIndex + 1);\n  return updated;\n};\nLet's use the above functions inside an example App component. We added two hooks inside it:\nconst [cellChangesIndex, setCellChangesIndex] = React.useState(() => -1);\nconst [cellChanges, setCellChanges] = React.useState<CellChange<TextCell>[][]>(\n  () => []\n);\nThe first one stores current index of changes for the second hook - storing an array of changes that has affected\nthe TextCells.We have wrapped ReactGrid with div element that listens to onKeyDown event.\nChanges can be also restored/redone with two buttons.Inside both methods (handleUndoChanges and handleRedoChanges) we update our data - poople array.\nThese changes come from cellChanges array.\nfunction App() {\n  const [people, setPeople] = React.useState<Person[]>(getPeople());\n  const [cellChangesIndex, setCellChangesIndex] = React.useState(() => -1);\n  const [cellChanges, setCellChanges] = React.useState<\n    CellChange<TextCell>[][]\n  >(() => []);\n  const rows = getRows(people);\n  const columns = getColumns();\n  const handleChanges = (changes: CellChange<TextCell>[]) => {\n    setPeople((prevPeople) => applyChangesToPeople(changes, prevPeople));\n  };\n  const handleUndoChanges = () => {\n    if (cellChangesIndex >= 0) {\n      setPeople((prevPeople) =>\n        undoChanges(cellChanges[cellChangesIndex], prevPeople)\n      );\n    }\n  };\n  const handleRedoChanges = () => {\n    if (cellChangesIndex + 1 <= cellChanges.length - 1) {\n      setPeople((prevPeople) =>\n        redoChanges(cellChanges[cellChangesIndex + 1], prevPeople)\n      );\n    }\n  };\n  return (\n    <div\n      onKeyDown={(e) => {\n        if ((!isMacOs() && e.ctrlKey) || e.metaKey) {\n          switch (e.key) {\n            case \"z\":\n              handleUndoChanges();\n              return;\n            case \"y\":\n              handleRedoChanges();\n              return;\n          }\n        }\n      }}\n    >\n      <ReactGrid rows={rows} columns={columns} onCellsChanged={handleChanges} />\n      <button onClick={handleUndoChanges}>Undo</button>\n      <button onClick={handleRedoChanges}>Redo</button>\n    </div>\n  );\n}","live-demo#Live demo":"And here's an interactive demo showing the Undo / Redo feature."}},"/docs/3.1/2-implementing-core-features/9c-internationalization":{"title":"Internationalization","data":{"":"Some of the translations are available for the PRO version","adding-i18n#Adding i18n":"ReactGrid has a few optional text labels that you could replace. All of the available translations are defined in\nTextLabels interface. You can create an object, and then pass it to labels\nproperty.\nreturn (\n\t<ReactGrid\n    {...props}\n    labels={{\n        copyLabel: 'Copy me!',\n        pasteLabel: 'Paste me!',\n        cutLabel: 'Cut me!',\n    }}\n\t/>\n);","locale-inside-cell-templates#Locale inside cell templates":"Some cell templates (NumberCell, DateCell,\nTimeCell) contain inside optional format field. This field uses\nIntl object of ECMAScript Internationalization API.\nWe suggest formatting cells content via mentioned API."}},"/docs/3.1/2-implementing-core-features/9d-responsive-sticky":{"title":"Responsive sticky","data":{"introduction#Introduction":"This feature disables sticky when the sum of the sizes of sticky panes overflows given breakpoint value (by default 50).","usage#Usage":"The feature is enabled by default. If you want to change the breakpoints value you can add horizontalStickyBreakpoint or\nverticalStickyBreakpoint property to ReactGrid component.In this example, sticky will disable when their width or height will be more than 40% of the viewport.\nreturn (\n  <div style={{ width: \"100vw\", height: \"100vh\" }}>\n    <ReactGrid\n      {...props}\n      stickyLeftColumns={3}\n      stickyTopRows={5}\n      horizontalStickyBreakpoint={40} \n      verticalStickyBreakpoint={40}\n    />\n  </div>\n);"}},"/docs/3.1/2-implementing-core-features/9e-cell-span":{"title":"Cell span","data":{"introduction#Introduction":"This feature is experimental, incomplete and can be changed in the future.\nThis feature allows you to set colspan and rowspan in a cell. Spanned cell don't pushes the other from their origin position.\nInsted, spanned cell stretches to desired size.","usage#Usage":"If you want to use it, please use only cells which type is header.\nThe use of this type of cell results in less undesirable behavior.\nCells that lie underneath the spanned cell should also be  marksed as header type.\nimport { Row } from \"@silevis/reactgrid\";\nconst row: Row = {\n    rowId: 0,\n    cells: [\n       { type: 'header', text: 'total', colspan: 3}, // highlight-line\n       { type: 'header', text: '' }, // highlight-line\n       { type: 'header', text: '' }, // highlight-line\n       { type: 'text', text: 'some text'},\n      // ...\n    ]\n}","caveats#Caveats":"Currently, the span of cells plays a visual role, functionalities related to interaction will be successively implemented\nin the future.\nFeature\tSupport\tDisplaying\t🟢\tHighlights\t🟢\tKeyboard actions\t🟠\tFocus\t🔴\tCell editor\t🔴\tCopy/cut/paste\t🔴\tSelection\t🔴\tFill handle\t🔴\tScrolling\t🔴"}},"/docs/3.1/4-cell-templates":{"title":"Cell templates","data":{"idea-of-cell-templates#Idea of cell templates":"In getting started chapter we declared cells array to be part of ReactGrid property.Each cell template has its own and unique behavior, content formatting and styling.Nothing stops you from creating your custom cell - read about creating your own cell template.In the listing below we declared two cells of header type, and they are related to the interface of HeaderCell\ntemplate.\ncells: [\n    { type: \"header\", text: \"Name\" },\n    { type: \"header\", text: \"Surname\" }\n]\nEvery cell object must contain type attribute, other keys depend on the exact type of a specific cell.","builtin-cell-templates#Builtin cell templates":"CheckboxCell\nDateCell\nDropdownCell\nEmailCell\nChevronCell\nHeaderCell\nNumberCell\nTextCell\nTimeCell"}},"/docs/3.1/4-cell-templates/2-CheckboxCell":{"title":"CheckboxCell","data":{"":"This cell type displays checkbox input. This template has disabled edit mode.","implementation#Implementation":"Open CheckboxCell implementation on  github","interface-declaration#Interface declaration":"interface CheckboxCell extends Cell {\n    type: 'checkbox';\n    checked: boolean;\n    checkedText?: string;\n    uncheckedText?: string;\n}\nProperty name\tType\tProperty description\ttype\tcheckbox\tType of cell template\tchecked\tboolean\tCurrent state of checked attribute in input element\tcheckedText?\tstring\tText of \"checked text input\", used while getting compatible cell, by default: 1\tuncheckedText?\tstring\tText of \"unchecked text input\",  used while getting compatible cell, by default: `` (empty string)"}},"/docs/3.1/4-cell-templates/3-DateCell":{"title":"DateCell","data":{"":"This template formats Date object and displays default browser date picker in edit mode.","implementation#Implementation":"Open DateCell implementation on  github","interface-declaration#Interface declaration":"interface DateCell extends Cell {\n    type: 'date';\n    date?: Date;\n    format?: Intl.DateTimeFormat;\n}\nProperty name\tType\tProperty description\ttype\tdate\tType of cell template\tdate?\tDate\tDate object, optional\tformat?\tIntl.DateTimeFormat\tFormats date, if undefined formats date according to the currect browser locale"}},"/docs/3.1/4-cell-templates/3a-DropdownCell":{"title":"DropdownCell","data":{"":"This cell renders dropdown from  react-select package.\nDropdownCell interface can be changed in the future","implementation#Implementation":"Open DropdownCell implementation on  github","interface-declaration#Interface declaration":"type OptionType = {\n  label: string\n  value: string\n}\ninterface DropdownCell extends Cell {\n  type: \"dropdown\"\n  selectedValue?: string\n  values: OptionType[]\n  isDisabled?: boolean\n  isOpen?: boolean\n  inputValue?: string\n}\nProperty name\tType\tProperty description\ttype\tdropdown\tType of cell template\tselectedValue\t?string\tCurrently selected option\tvalues?\tOptionType[]\tAn array of options\tisDisabled?\t?boolean\tDisables dropdown from opening\tisOpen?\t?boolean\tControls current state of open/close\tinputValue?\t?string\tA value typed into a dropdown filter"}},"/docs/3.1/4-cell-templates/4-EmailCell":{"title":"EmailCell","data":{"":"This cell renders text value with the possibility to validate its value and wrap the result into React.ReactNode objects.","implementation#Implementation":"Open EmailCell implementation on  github","interface-declaration#Interface declaration":"interface EmailCell extends Cell {\n  type: \"email\"\n  text: string\n  validator?: (text: string) => boolean\n  renderer?: (text: string) => React.ReactNode\n}\nProperty name\tType\tProperty description\ttype\temail\tType of cell template\ttext\tstring\tText content of cell\tvalidator?\t(text: string) => boolean\tOptional validation function, if undefined - returns true\trenderer?\t(text: string) => React.ReactNode\tOptional, gives oportunity to wrap text property into any ReactNode object"}},"/docs/3.1/4-cell-templates/5-ChevronCell":{"title":"ChevronCell","data":{"":"ChevronCell contains data about a single node in the tree structure of the data. This cell template renders text with\nthe preceding chevron.Implementation of grouping functionality remains on developer (e.g., creating tree structure of cells,\nfiltering rows available to display, creating indents).hasChildren field is necessary to display ChevronCell.","implementation#Implementation":"Open ChevronCell implementation on  github","interface-declaration#Interface declaration":"interface ChevronCell extends Cell {\n    type: 'chevron';\n    text: string;\n    isExpanded?: boolean;\n    hasChildren?: boolean;\n    parentId?: Id;\n    indent?: number;\n}\nProperty name\tType\tProperty description\ttype\tchevron\tType of cell template\ttext\tstring\tText of cell content\tisExpanded?\tboolean\tIs node expaned (displays chevron char as opened/closed)\thasChildren?\tboolean\tDetermines if a node element has children\tparentId?\tId\tId of parent node (cell), if undefined the node becomes a root\tindent?\tnumber\tIndent size of cell content"}},"/docs/3.1/4-cell-templates/7-NumberCell":{"title":"NumberCell","data":{"":"Displays number, this cell allows to customize format number values using Intl.NumberFormat.","implementation#Implementation":"Open NumberCell implementation on  github","interface-declaration#Interface declaration":"interface NumberCell extends Cell {\n    type: 'number';\n    value: number;\n    format?: Intl.NumberFormat;\n    nanToZero?: boolean;\n    hideZero?: boolean;\n}\nProperty name\tType\tProperty description\ttype\theader\tType of cell template\tvalue\tnumber\tValue of cell\tformat?\tIntl.NumberFormat\tFormats value, if undefined formats number according to currect browser locale\tnanToZero?\tboolean\tIf value equals NaN then displays 0\thideZero?\tboolean\tIf displayed value equals 0 then value is not rendered"}},"/docs/3.1/4-cell-templates/6-HeaderCell":{"title":"HeaderCell","data":{"":"The main purpose of this cell is to mark its content as not focusable and read-only. Usually used to mark header rows\nand columns. HeaderCell also prevents scroll action (it's helpfull on a touch screens to perform row and column selection).\nHeaderCell interface is extended by Span, therefore you can span this cell.","implementation#Implementation":"Open HeaderCell implementation on  github","interface-declaration#Interface declaration":"interface HeaderCell extends Cell, Span {\n    type: 'header';\n    text: string;\n}\nProperty name\tType\tProperty description\ttype\theader\tType of cell template\ttext\tstring\tContent of cell"}},"/docs/3.1/4-cell-templates/8-TextCell":{"title":"TextCell","data":{"":"This template allows to display text as a string value. Optionally it also gives\na possibility to change rendering method and validate displaying text.","implementation#Implementation":"Open TextCell implementation on  github","interface-declaration#Interface declaration":"interface TextCell extends Cell {\n    type: 'text',\n    text: string,\n    placeholder?: string,\n    validator?: (text: string) => boolean,\n    renderer?: (text: string) => React.ReactNode\n}\nProperty name\tType\tProperty description\ttype\theader\tType of cell template\ttext\tstring\tText content of cell\tplaceholder?\tstring\tOptional, when text property is empty, display this value in placeholder input style\tvalidator?\t(text: string) => boolean\tOptional validation function, if undefined - returns true\trenderer?\t(text: string) => React.ReactNode\tOptional, gives oportunity to wrap text property into any ReactNode object"}},"/docs/3.1/5-create-your-own-cell-template":{"title":"Create your own cell template","data":{"introduction#Introduction":"Creating a cell template is the best way to customize data visualization and behaviour in ReactGrid.\nYou can define your own one and then use it as other built-in cell types.In this example, we will explain how to make it.Let's imagine that you need to implement a brand new cell for displaying a country flag.Expected functionality:\nIn edit mode a cell allows you to type in text without any constraints\nWhen a cell is displayed, it should show a country flag based on the cell text\nLet's get started!","1-define-flag-cell-interface#1. Define flag cell interface":"For this tutorial we are going to use the previous project - handling changes.type attribute is necessary in any cell template, in our sample we will refer to this cell template by flag.\ntext attribute will store our ISO code and it's also necessary.\nexport interface FlagCell extends Cell {\n    type: 'flag';\n    text: string;\n}","2-data-holders#2. Data holders":"At the beginning we should update columns and rows displayed by the grid.\nOur data is no longer a people array, but a flag indentified by its isoCode.\ninterface Flag {\n  isoCode: string;\n}\nconst getFlags = (): Flag[] => [\n  { isoCode: \"swe\" },\n  { isoCode: \"deu\" },\n  { isoCode: \"mex\" },\n  { isoCode: \"\" }\n];\nconst getColumns = (): Column[] => [{ columnId: \"flag\", width: 150 }];","3-creating-necessary-files#3. Creating necessary files":"Create new file named FlagCellTemplate.tsx, add the same imports as in the listing below and make flag-cell-style.css\nfile that will contain some CSS styles (don't forget to import it into your project's file).\n// FlagCellTemplate.tsx\nimport * as React from \"react\";\nimport {\n  CellTemplate,\n  Cell,\n  Compatible,\n  Uncertain,\n  UncertainCompatible,\n  isNavigationKey,\n  getCellProperty,\n  isAlphaNumericKey,\n  keyCodes\n} from \"@silevis/reactgrid\";\nimport \"./flag-cell-style.css\";","4-creating-flagcelltemplate-class#4. Creating FlagCellTemplate class":"For all defined methods below it is necessary to display and interface the flag cell with internal ReactGrid model correctly.\ngetCompatibleCell as a parameter gets an incoming cell and returns a compatible cell (with text and value\nattribute required by Compatible type).\nIn more complex examples getCellProperty may throw an exception if the required cell field is undefined.\ngetCompatibleCell(uncertainCell: Uncertain<FlagCell>): Compatible<FlagCell> {\n    const text = getCellProperty(uncertainCell, 'text', 'string');\n    const value = parseFloat(text);\n    return { ...uncertainCell, text, value };\n}\nhandleKeyDown method handles keyDown event on this cell template. Here it just returns unchanged cell and enables\nedit mode when a user performed a click or pressed ENTER key.\nhandleKeyDown(\n    cell: Compatible<FlagCell>,\n    keyCode: number,\n    ctrl: boolean,\n    shift: boolean,\n    alt: boolean\n): { cell: Compatible<FlagCell>; enableEditMode: boolean } {\n    if (!ctrl && !alt && isAlphaNumericKey(keyCode))\n        return { cell, enableEditMode: true };\n    return {\n        cell,\n        enableEditMode: keyCode === keyCodes.POINTER || keyCode === keyCodes.ENTER\n    };\n}\nupdate - as we are not sure if an incoming cell has the same interface like FlagCell so we mark it\nas UncertainCompatible (the incoming cell has attributes provided by Compatible\nbut it can have other attributes like date from DateCell). In our case, we just copy cell and replace text value.\nupdate(cell: Compatible<FlagCell>, cellToMerge: UncertainCompatible<FlagCell>): Compatible<FlagCell> {\n    return this.getCompatibleCell({ ...cell, text: cellToMerge.text });\n}\nrender method returns the content of a cell. In edit mode we will display input element. The change which is made in the\ncell input is propagated outside ReactGrid by onCellChanged function.\nrender(\n    cell: Compatible<FlagCell>,\n    isInEditMode: boolean,\n    onCellChanged: (cell: Compatible<FlagCell>, commit: boolean) => void\n): React.ReactNode {\n  if (!isInEditMode) {\n    const flagISO = cell.text.toLowerCase(); // ISO 3166-1, 2/3 letters\n    const flagURL = `https://restcountries.eu/data/${flagISO}.svg`;\n    const alternativeURL = `https://upload.wikimedia.org/wikipedia/commons/0/04/Nuvola_unknown_flag.svg`;\n    return (\n      <div\n        className=\"rg-flag-wrapper\"\n        style={{ backgroundImage: `url(${flagURL}), url(${alternativeURL})` }}\n      />\n    );\n  }\n  return (\n    <input\n      ref={input => {\n        input && input.focus();\n      }}\n      defaultValue={cell.text}\n      onChange={e =>\n        onCellChanged(\n          this.getCompatibleCell({ ...cell, text: e.currentTarget.value }),\n          false\n        )\n      }\n      onCopy={e => e.stopPropagation()}\n      onCut={e => e.stopPropagation()}\n      onPaste={e => e.stopPropagation()}\n      onPointerDown={e => e.stopPropagation()}\n      onKeyDown={e => {\n      if (isAlphaNumericKey(e.keyCode) || isNavigationKey(e.keyCode))\n        e.stopPropagation();\n      }}\n    />\n  );\n}","5-styling#5. Styling":"To set a flag as the background covering the div element, we created CSS rg-flag-wrapper class.\nAll of the cells have a class name created based on the cell type attribute. In our case, the cell class name will be rg-flag-cell.\nAs rg-cell is a flex element we center its content with justify-content: center; attribute.\n.rg-flag-cell {\n  justify-content: center;\n}\n.rg-flag-wrapper {\n  width: 50%;\n  height: 80%;\n  background-size: cover;\n  border: 1px solid #cccccc;\n  background-position: center center;\n  background-repeat: no-repeat;\n}","6-updating-header-row-and-generating-flag-rows#6. Updating header row and generating flag rows":"Header row is still static, but displays only one cell.\nconst headerRow: Row = {\n  rowId: \"header\",\n  height: 40,\n  cells: [{ type: \"header\", text: \"Flags\" }]\n};\ngetRows function now process the flags array, and return array of Row<DefaultCellTypes | FlagCell>.\nThis record tells us that cells rows can be on one of DefaultCellTypes (build-in cell types) or brand new\ntemplate - FlagCell with type of flag.\nconst getRows = (flags: Flag[]): Row<DefaultCellTypes | FlagCell>[] => [\n  headerRow,\n  ...flags.map<Row<DefaultCellTypes | FlagCell>>((flag, idx) => ({\n    rowId: idx,\n    height: 60,\n    cells: [{ type: \"flag\", text: flag.isoCode }]\n  }))\n];","7-finishing#7. Finishing":"Go back to index.tsx file and add customCellTemplates property as shown below:\nfunction App() {\n  const [flags] = React.useState<Flag[]>(getFlags());\n  const rows = getRows(flags);\n  const columns = getColumns();\n  return (\n    <ReactGrid\n      rows={rows}\n      columns={columns}\n      customCellTemplates={{ flag: new FlagCellTemplate() }}\n    />\n  );\n}","result#Result":""}},"/docs/3.1/4-cell-templates/9-TimeCell":{"title":"TimeCell","data":{"":"This template formats Date object and displays default browser time picker in edit mode.\nKeep in mind: time attribute that stores Date object instance will be stored with the date of January 1st, 1970 UTC.","implementation#Implementation":"Open TimeCell implementation on  github","interface-declaration#Interface declaration":"interface TimeCell extends Cell {\n    type: 'time';\n    time?: Date;\n    format?: Intl.DateTimeFormat;\n}\nProperty name\tType\tProperty description\ttype\tdate\tType of cell template\ttime?\tDate\tDate object, optional\tformat?\tIntl.DateTimeFormat\tFormats time, if undefined formats it according to current browser locale"}},"/docs/3.1/6-styling":{"title":"Styling","data":{"":"In this chapter, you will learn about simple and advanced ReactGrid components styling using Sass variables.\nBasic styling\nAdvanced styling\nSass variables"}},"/docs/3.1/6-styling/1-advanced-styling":{"title":"Advanced styling","data":{"":"ReactGrid lets you style all key components using Sass variables.Before you use .scss files you have to install node-sass package:\nnpm install node-sass\nTo override default styles of ReactGrid you have to assign new values\n(available variables) and then import all  necessary .scss files.\nIf variable is not passed before getting imported core.scss it will not be modified.Here's an example of how to add custom focus style on your grid.\n// Your custom color\n$primary-color: #3579f8;\n@import '@silevis/reactgrid/styles.scss';\nSee full styling example below:\nIf you use multiple grids on the same page, make sure your grid styles are 'local'.\n// Independent ReactGrid classess\n#reactgrid-red {\n    $primary-color: red;\n    @import '@silevis/reactgrid/styles.scss';\n}\n#reactgrid-blue {\n    $primary-color: blue;\n    @import '@silevis/reactgrid/styles.scss';\n}\nWrap ReactGrid component into div element with class name:\n<div id=\"reactgrid-red\">\n    <ReactGrid {...props}/>\n</div>\n<div id=\"reactgrid-blue\">\n    <ReactGrid {...props}/>\n</div>"}},"/docs/3.1/6-styling/0-basic-styling":{"title":"Basic styling","data":{"introduction#Introduction":"For the correct display of the component it's required to import the basic styles contained directly inside\n@silevis/reactgrid package.","importing#Importing":"Styles are a necessary part of ReactGrid. For a correct display you have to import ReactGrid into your project.\n/* your-styles.css */\n@import '@silevis/reactgrid/styles.css';\nor if you use Sass preprocessor:\n/* your-styles.scss */\n@import '@silevis/reactgrid/styles.scss';\nYou can only import files that you need and then override variables yourself:\n/* your-styles.scss */\n@import './default-colors.scss';\n@import './default-sizing.scss';\n@import './cell-templates-default-colors.scss';\n@import './mapping.scss';\n@import './cell-templates.scss';\n@import './main.scss';"}},"/docs/3.1/6-styling/2-sass-variables":{"title":"Sass variables","data":{"":"ReactGrid uses an expanded set of variables you can override.","color-related-variables#Color related variables":"","color-variables#Color variables":"$primary-color: #3579f8 !default;\n$bg-color: #ffffff !default;\n$sticky-bg-color: #ffffff !default;\n$shadow-color: #000000 !default;\n$resize-line-color: #74b9ff !default;\n$resize-hint-bg-color: $resize-line-color !default;\n$resize-handle-gb-color: $primary-color !default;\n$cell-border-color: #111111 !default;\n$cell-editor-bg-color: #ffffff !default;\n$cell-editor-border-color: $primary-color !default;\n$fillhandle-action-border-color: #000000 !default;\n$partial-area-gb-color: $primary-color !default;\n$partial-area-border-color: $primary-color !default;\n$checkbox-checked: $primary-color !default;\n$checkbox-unchecked: #eeeeee !default;\n$checkbox-hover: #cccccc !default;\n$checkbox-mark: #ffffff !default;\n$dropdown-focused-item-bg-color: lighten(\n    $color: $primary-color,\n    $amount: 35,\n) !default;\n$dropdown-menu-bg-color: #ffffff !default;","shadow-variables#Shadow variables":"$shadow-blur-radius: 3px !default;\n$shadow-spread-radius: 1px !default;\n$shadow-length: 1px !default;\n$cell-editor-shadow: 1px 1px 6px !default;","context-menu-variables#Context menu variables":"$context-menu-shadow: 0px 0px 8px 2px !default;","opacity-variables#Opacity variables":"$opacity-80: 0.8 !default;\n$opacity-35: 0.35 !default;\n$opacity-20: 0.2 !default;\n$opacity-15: 0.15 !default;\n$opacity-10: 0.1 !default;\n$opacity-06: 0.06 !default;\n$opacity-01: 0.01 !default;","size-related-variables#Size related variables":"$cell-font-size:                        1em !default;\n$context-menu-font-size:                1em !default;\n$cell-padding:                          0 4px !default;\n$cell-focus-border-width:               2px !default;\n$celleditor-border-width:               2px !default;\n$celleditor-padding-top:                1px !default;\n$fill-handle-area:                      40px !default;\n$fill-handle-square:                    6.5px !default;\n$fill-handle-border-width:              1px !default;\n$resize-handle-area:                    11px !default;\n$resize-handle-line-width:              6px !default;\n$line-size:                             2px !default;\n$partial-area-border-width:             1px !default;\n$partial-area-selected-border-width:    1px !default;\n$checkbox-size:                         18px !default;\n$context-menu-option-padding:           8px 20px 8px 15px !default;","core-cell-templates-variables#Core cell templates variables":"$template-checkbox-size:    20px !default;\n$template-font-size:        1em !default;\n$template-bg-color:         transparent !default;\n$template-padding:          0 !default;\n$template-margin:           0 !default;\n$template-content-invalid:  rgb(255, 0, 0) !default;"}},"/docs/3.1/7-api":{"title":"API Reference","data":{"":"ReactGrid API contains interfaces, types and functions exported from ReactGrid package to compose grids,\ndefine custom behaviour and data visualization.\nInterfaces\nTypes\nFunctions & Enums"}},"/docs/3.1/7-api/0-interfaces":{"title":"Interfaces","data":{"":"ReactGrid API provides following interfaces:","interfaces#Interfaces":"ReactGridProps\nRow\nColumn\nCell\nCellTemplates\nCellTemplate\nCellChange\nCellLocation\nCellStyle\nMenuOption\nHighlight\nTextLabels"}},"/docs/3.1/7-api/0-interfaces/1-reactgrid-props":{"title":"ReactGrid & ReactGridProps","data":{"":"ReactGrid component has two essential properties which you must pass in properties to render - columns and rows.","definition#Definition":"interface ReactGridProps {\n    readonly columns: Column[];\n    readonly rows: Row<Cell>[];\n    readonly customCellTemplates?: CellTemplates;\n    readonly focusLocation?: CellLocation;\n    readonly initialFocusLocation?: CellLocation;\n    readonly highlights?: Highlight[];\n    readonly stickyTopRows?: number;\n    readonly stickyBottomRows?: number;\n    readonly stickyLeftColumns?: number;\n    readonly stickyRightColumns?: number;\n    readonly enableFillHandle?: boolean;\n    readonly enableRangeSelection?: boolean;\n    readonly enableRowSelection?: boolean;\n    readonly enableColumnSelection?: boolean;\n    readonly labels?: TextLabels;\n    readonly enableFullWidthHeader?: boolean;\n    readonly enableGroupIdRender?: boolean;\n    readonly horizontalStickyBreakpoint?: number;\n    readonly verticalStickyBreakpoint?: number;\n    readonly onCellsChanged?: (cellChanges: CellChange[]) => void;\n    readonly onFocusLocationChanged?: (location: CellLocation) => void;\n    readonly onFocusLocationChanging?: (location: CellLocation) => boolean;\n    readonly onColumnResized?: (columnId: Id, width: number, selectedColIds: Id[]) => void;\n    readonly onRowsReordered?: (targetRowId: Id, rowIds: Id[], dropPosition: DropPosition) => void;\n    readonly onColumnsReordered?: (targetColumnId: Id, columnIds: Id[], dropPosition: DropPosition) => void;\n    readonly onContextMenu?: (selectedRowIds: Id[], selectedColIds: Id[], selectionMode: SelectionMode, menuOptions: MenuOption[], selectedRanges: Array<CellLocation[]>) => MenuOption[];\n    readonly canReorderColumns?: (targetColumnId: Id, columnIds: Id[], dropPosition: DropPosition) => boolean;\n    readonly canReorderRows?: (targetRowId: Id, rowIds: Id[], dropPosition: DropPosition) => boolean;\n}","properties#Properties":"Name\tType\tDescription\tcolumns\tColumns[]\tColumn's data\trows\tRows<Cell>[]\tRow's data\tcustomCellTemplates?\tCellTemplates\tSet of available custom cell templates\tfocusLocation?\tCellLocation\tFocus position (managed constantly by outer app)\tinitialFocusLocation?\tCellLocation\tInitial position of focus\thighlights?\tHighlight[]\tArray of highlight positions\tstickyTopRows?\tnumber\tAmount of rows which are sticky at the top\tstickyBottomRows?\tnumber\tAmount of rows which are sticky at the bottom\tstickyLeftColumns?\tnumber\tAmount of columns which are sticky on the left side\tstickyRightColumns?\tnumber\tAmount of columns which are sticky on the right side\tenableFillHandle?\tboolean\tSet true to enable cell fill feature (by default false)\tenableRangeSelection?\tboolean\tSet true to enable selection feature (by default false)\tenableRowSelection?\tboolean\tSet true to enable row selection feature (by default false)\tenableColumnSelection?\tboolean\tSet true to enable column selection feature (by default false)\tlabels?\tTextLabels\tObject that contains labels of texts used by ReactGrid\tenableFullWidthHeader?\tboolean\tSet true to enable full width header (by default false, feature is experimental)\tenableGroupIdRender?\tboolean\tSet true to enable groupId element rendering (by default false)\treadonly horizontalStickyBreakpoint?\tnumber\tHorizontal breakpoint in percents (%) of ReactGrid scrollable parent element width. Disables sticky when the sum of the sizes of sticky panes overflows given breakpoint value (by default 50)\tverticalStickyBreakpoint?\tnumber\tVertical breakpoint in percents (%) of ReactGrid scrollable parent element height. Disables sticky when the sum of the sizes of sticky panes overflows given breakpoint value (by default 50)","callbacks#Callbacks":"Name\tType\tDescription\tonCellsChanged?\t(cellChanges: CellChange[]) => void;\tCalled when cell property (e.g. value) was changed\tonFocusLocationChanged?\t(location: CellLocation) => void;\tFocus position has been changed\tonFocusLocationChanging?\t(location: CellLocation) => boolean;\tCalled when trying to change focus location. Return false to prevent position changing\tonColumnResized?\t(columnId: Id, dropPosition: DropPosition) => void;\tCallback called when column resize action was ended\tonRowsReordered?\t(targetRowId: Id, rowIds: Id[], dropPosition: DropPosition) => void;\tCallback called when row reorder action was ended\tonColumnsReordered?\t(targetColumnId: Id, columnIds: Id[], dropPosition: DropPosition) => void;\tCallback called when column reorder action was ended\tonContextMenu?\t(selectedRowIds: Id[], selectedColIds: Id[], selectionMode: SelectionMode, menuOptions: MenuOption[], selectedRanges: Array<CellLocation[]>) => MenuOption[];\tCalled when user opens context menu inside grid, used to compose own menu options\tcanReorderColumns?\t(targetColumnId: Id, columnIds: Id[], dropPosition: DropPosition) => boolean;\tAllow or not to change specific columns order\tcanReorderRows?\t(targetRowId: Id, rowIds: Id[], dropPosition: DropPosition) => boolean;\tAllow or not to change specific rows order"}},"/docs/3.1/7-api/0-interfaces/3-column":{"title":"Column","data":{"":"This interface represents column in grid. Column interface contains only one necessary property: columnId.","definition#Definition":"interface Column {\n    readonly columnId: Id;\n    readonly width?: number;\n    readonly reorderable?: boolean;\n    readonly resizable?: boolean;\n}","properties#Properties":"Property name\tType\tProperty description\tcolumnId\tId\tUnique Id in all columns array\twidth?\tnumber\tWidth of each grid column (in default set to 150px)\treorderable?\tboolean\tAllow column to change its position in grid, default: false (row reorder implementation is on the developers side)\tresizable?\tboolean\tAllow column to change is width in grid, default: false (row resize implementation is on the developers side)"}},"/docs/3.1/7-api/0-interfaces/4-cell":{"title":"Cell","data":{"":"Cell interface is a base for built-in cell templates and your own, it has only one necessary property - type.","definition#Definition":"interface Cell {\n    type: string;\n    nonEditable?: boolean;\n    groupId?: Id;\n    style?: CellStyle;\n    className?: string;\n}","properties#Properties":"Properties\tType\tProperties description\ttype\tstring\tName of cell type, must be unique\tnonEditable?\tboolean\tMakes cell non editable - this property takes precedence over cell templating\tgroupId?\tId\tId of group to which this cell belongs to\tstyle?\tCellStyle\tAllowed style properties contained in CellStyle interface\tclassName?\tstring\tAdditional CSS classes\tcolspan?\tnumber\tSpecifies the number of columns a cell should span\trowspan?\tnumber\tSpecifies the number of rows a cell should span"}},"/docs/3.1/7-api/0-interfaces/6-cell-location":{"title":"CellLocation","data":{"":"CellLocation is an interface that describes position inside the grid.","definition#Definition":"interface CellLocation {\n    readonly rowId: Id;\n    readonly columnId: Id;\n}","properties#Properties":"Property name\tType\tProperty description\trowId\tId\tRow Id of cell location\tcolumnId\tId\tColumn Id of cell location"}},"/docs/3.1/7-api/0-interfaces/6a-cell-templates":{"title":"CellTemplates","data":{"":"CellTemplates is an interface describes your custom cell templates as key-value object.\nKey of CellTemplates interface have to be equal to coresponding cell type field (with extends Cell interface).","definition#Definition":"interface CellTemplates {\n    [key: string]: CellTemplate;\n}","example#Example":"const myCellTemplates: CellTemplates = {\n    'flag': FlagCellTemplate,\n    'dropdownNumber': DropdownNumberCellTemplate,\n}\nreturn (\n    <ReactGrid\n      {...props}\n      customCellTemplates={myCellTemplates} // highlight-line\n    />\n);","properties#Properties":"Properties\tType\tProperties description\t[key: string]\tCellTemplate\tType of a cell template and its implementation"}},"/docs/3.1/7-api/0-interfaces/7-cell-style":{"title":"CellStyle","data":{"":"CellStyle styles single cell and prevents passing unwanted CSS properties that could break down view rendering.\nThis interface uses also a BorderProps to style particular cells border edge.","definition#Definition":"interface CellStyle {\n    readonly color?: string;\n    readonly background?: string;\n    readonly overflow?: string;\n    readonly paddingLeft?: string;\n    readonly border?: {\n        readonly left?: BorderProps;\n        readonly top?: BorderProps;\n        readonly right?: BorderProps;\n        readonly bottom?: BorderProps;\n    }\n}\ninterface BorderProps {\n    readonly color?: string;\n    readonly style?: string;\n    readonly width?: string;\n}","properties#Properties":"CellStyle interface properties.\nProperty name\tType\tProperty description\tcolor?\tstring\tCSS color property\tbackground?\tstring\tCSS background property\toverflow?\tstring\tCSS overflow property\tpaddingLeft?\tstring\tCSS padding-left property\tborder?\t{ left?: BorderProps; top?: BorderProps; right?: BorderProps; bottom?: BorderProps; }\tObject that contains all cell's borders properties\t\nBorderProps interface properties. By default, cell has only right and bottom border, except cells on panes edges.\nIf you want to style cell border properly, it's important to declare all properties: color, style, width.\nProperty name\tType\tProperty description\tcolor?\tstring\tColor of border - e.g. #eee/red\tstyle?\tstring\tStyle of border - e.g. dotted/solid\twidth?\tstring\tWidth of border - e.g. 2px"}},"/docs/3.1/7-api/0-interfaces/8-menuoption":{"title":"MenuOption","data":{"":"The context menu is part of the grid, each menu option must implement the interface below.","definition#Definition":"interface MenuOption {\n    id: string;\n    label: string;\n    handler: (selectedRowIds: Id[], selectedColIds: Id[], selectionMode: SelectionMode, selectedRanges: Array<CellLocation[]>) => void;\n}","properties#Properties":"Property name\tType\tProperty description\tid\tstring\tText that identifies each menu option\tlabel\tstring\tLabel displayed in menu\thandler\t(selectedRowIds: Id[], selectedColIds: Id[], selectionMode: SelectionMode, selectedRanges: Array<CellLocation[]>) => void`\tFunction that is called when option is clicked"}},"/docs/3.1/7-api/0-interfaces/5-cell-template":{"title":"CellTemplate","data":{"":"CellTemplate is an interface used for communication between ReactGrid and a cell.\nAt this stage if you are still not familiar with cell marker interfaces, it might be helpful to read about them:\nCompatible\nUncertainCompatible\nUncertain","definition#Definition":"interface CellTemplate<TCell extends Cell = Cell> {\n    // Validate and convert to compatible cell type\n    getCompatibleCell(uncertainCell: Uncertain<TCell>): Compatible<TCell>;\n    // Returns true if the data in the cell is not replacable\n    // Default: _ => true\n    isFocusable?(cell: Compatible<TCell>): boolean;\n    // Update cell based on new props\n    // If not implemented, cell will be read-only\n    update?(cell: Compatible<TCell>, cellToMerge: UncertainCompatible<TCell>): Compatible<TCell>;\n    // The keyCode represents the key pressed on the keyboard, or 1 for a pointer event (double click).\n    // Returns the cell data either affected by the event or not.\n    // Default: cell => { cell, enableEditMode: false }\n    handleKeyDown?(cell: Compatible<TCell>, keyCode: number, ctrl: boolean, shift: boolean, alt: boolean): { cell: Compatible<TCell>; enableEditMode: boolean };\n    // Custom styles based on cell data applied to the cells div element\n    // Default: _ => cell.style | {}\n    getStyle?(cell: Compatible<TCell>, isInEditMode: boolean): CellStyle;\n    // Custom class names based on cell data applied to the cells div element\n    // Default: _ => cell.className | ''\n    getClassName?(cell: Compatible<TCell>, isInEditMode: boolean): string;\n    // Render the cell content\n    render(cell: Compatible<TCell>, isInEditMode: boolean, onCellChanged: (cell: Compatible<TCell>, commit: boolean) => void): React.ReactNode;\n}","properties#Properties":"Method\tReturns\tDescription\tgetCompatibleCell(uncertainCell: Uncertain<TCell>)\tCompatibleCell<TCell>\tValidates and converts into a compatible cell type\tisFocusable?(cell: Compatible<TCell>)\tboolean\tMarks a cell as focusable or not\tupdate?(cell: Compatible<TCell>, cellToMerge: UncertainCompatible<TCell>)\tCompatibleCell<TCell>\tUpdates cell based on new properties, if not implemented, a cell will be read-only\thandleKeyDown?(cell: Compatible<TCell>, keyCode: number, ctrl: boolean, shift: boolean, alt: boolean)\t{ cell: CompatibleCell<TCell>; enableEditMode: boolean }\tReturns the cell data either affected by an event or not.\tgetStyle?(cell: Compatible<TCell>, isInEditMode: boolean)\tCellStyle\tReturns custom styles based on cell data applied to the cells div element\tgetClassName?(cell: Compatible<TCell>, isInEditMode: boolean)\tstring\tReturns custom class names based on cell data applied to the cells div element\trender(cell: Compatible<TCell>, isInEditMode: boolean, onCellChanged: (cell: Compatible<TCell>, commit: boolean) => void)\tReact.ReactNode\tRenders cell content"}},"/docs/3.1/7-api/0-interfaces/9-highlight":{"title":"Highlight","data":{"":"Highlight is an element to mark any cell inside the grid with custom border color or CSS classHighlight (opposed to focus):\nit can be placed on any cell\nit must be managed by a developer unlike 'focus'","definition#Definition":"interface Highlight {\n    readonly rowId: Id;\n    readonly columnId: Id;\n    readonly borderColor?: string;\n    readonly className?: string;\n}","properties#Properties":"Property name\tType\tProperty description\trowId\tId\tRow Id of the cell to highlight\tcolumnId\tId\tColumn Id of the cell to highlight\tborderColor\tstring\tOptional border color\tclassName\tstring\tOptional CSS classname of the highlighted cell"}},"/docs/3.1/7-api/1-types":{"title":"Types","data":{"":"ReactGrid API provides following types:\nCompatible\nCellChange\nUncertain\nUncertainCompatible\nId\nDropPosition\nDefaultCellTypes\nSelectionMode"}},"/docs/3.1/7-api/0-interfaces/90-textlabels":{"title":"TextLabels","data":{"":"TextLabels describes a set of text labels used by ReactGrids internal i18n module.\nEach text label has its own default value.","definition#Definition":"interface TextLabels {\n    legacyBrowserHeader?: string,\n    legacyBrowserText?: string,\n    copyLabel?: string,\n    cutLabel?: string,\n    pasteLabel?: string,\n    macOsContextMenuPasteAlert?: string,\n    otherBrowsersContextMenuPasteAlert?: string,\n    contextMenuPasteAlert?: string\n}","properties#Properties":"Property name\tType\tProperty description\tlegacyBrowserHeader?\tstring\tLabel of text header when browser isn't supported, by default: Please update to a modern browser.\tlegacyBrowserText?\tstring\tLabel of text paragraph when browser isn't supported, by default: Your current browser cannot run our content, please make sure you browser is fully updated or try adifferent browser. We highly recommend using the most recent release of Google Chrome, Microsoft Edge, Firefox, Safari, and Opera browser\tcopyLabel?\tstring\tLabel of copy action displayed inside context menu (just PRO), by default: Copy\tcutLabel?\tstring\tLabel of cut action displayed inside context menu (just PRO), by default: Cut\tpasteLabel?\tstring\tLabel of paste action displayed inside context menu (just PRO), by default: Paste\tmacOsContextMenuPasteAlert?\tstring\tAlert label in use (e.g. MacOS) if access to the clipboard is denied (just PRO), by default: Use ⌘ + c for copy, ⌘ + x for cut and ⌘ + v for paste.\totherBrowsersContextMenuPasteAlert?\tstring\tAlert label in use (e.g. Firefox) if access to the clipboard is denied (just PRO), by default:  Use ctrl + c for copy, ctrl + x for cut and ctrl + v for paste.\tcontextMenuPasteAlert?\tstring\tAlert label in use (e.g. Firefox) if access to the clipboard is denied (just PRO), by default: This action is not supported in this browser."}},"/docs/3.1/7-api/1-types/2-cell-change":{"title":"CellChange","data":{"":"CellChange type is used by onCellsChanged callback in ReactGrid component. It represents\nmutually exclusive changes to a single cell.CellTypes utility type extracts all possible cell types based on Cell interface.Generic Change interface represents a particullar change on single cell on concrete cell template.","basic-usage-cases#Basic usage cases":"const handleChangesOnDefaults = (changes: CellChange[]) => { // evaluates as `Change<TextCell> | Change<Datecell> | ...`\n  changes.forEach(change => {\n    if (change.type === 'checkbox') {\n      console.log(change.newCell.checked);\n      console.log(change.previousCell.checked);\n    }\n  });\n};\nconst handleChangesOnDefaultsAndFlagCell = (changes: CellChange<DefaultCellTypes | FlagCell>[]) => { // evaluates as `Change<TextCell> | Change<Datecell> | ... | Change<FlagCell>`\n  changes.forEach(change => {\n    if (change.type === 'flag') {\n      // `FlagCell` specyfic fields are now available\n      console.log(change.newCell.text);\n      console.log(change.previousCell.text);\n    }\n  });\n};\nconst handleChangesOnlyOnDateCell = (changes: CellChange<DateCell>[]) => { // evaluates as `Change<DateCell>`\n  changes.forEach(change => {\n    // only available type is now `date`\n    if (change.type === 'date') {\n      console.log(change.newCell.date);\n      console.log(change.previousCell.date);\n    }\n  });\n};","definition#Definition":"declare type CellChange<TCell extends Cell = DefaultCellTypes & Cell> = TCell extends Cell ? {\n    /** Row's `Id` where the change ocurred */\n    readonly rowId: Id;\n    /** Column's `Id` where the change ocurred */\n    readonly columnId: Id;\n    /** Extracted cell type of `TCell` (e.g. `text`, `chevron` and so on) */\n    readonly type: TCell['type'];\n    /** Previous content of the cell */\n    readonly previousCell: TCell;\n    /** New content of the cell */\n    readonly newCell: TCell;\n} : never;\nTCell is type that extends common Cell type.\nIt can be one of default cell types or one of yours.\nRead more about creating custom cell templates.","properties#Properties":"Property name\tType\tProperty description\trowId\tId\tRow Id where the change ocurred\tcolumnId\tId\tColumn Id where the change ocurred\ttype\tCellTypes<TCell>\tExtracted cell type of TCell e.g. text, chevron\tpreviousCell\tTCell extends Cell = Cell\tPrevious content of the cell\tnewCell\tTCell extends Cell = Cell\tNew content of the cell"}},"/docs/3.1/7-api/1-types/1-compatible-cell":{"title":"Compatible","data":{"":"CompatibleCell is an extended and exchangeable cell (compatible with different types).","definition#Definition":"type Compatible<TCell extends Cell> = TCell & {\n    text: string;\n    value: number;\n}","properties#Properties":"Property name\tType\tProperty description\ttext\tstring\tText value of a cell\tvalue\tnumber\tNumeric value of a cell, if there is no numeric value representation use NaN"}},"/docs/3.1/7-api/1-types/3-uncertain-compatible-cell":{"title":"UncertainCompatible","data":{"":"UncertainCompatible is a cell type that is compatible with other cell types\nthat can be instances of various cell types (e.g. DataCell and TimeCell).","definition#Definition":"type UncertainCompatible<TCell extends Cell> = Uncertain<TCell> & {\n    text: string;\n    value: number;\n}"}},"/docs/3.1/7-api/1-types/2-uncertain-cell":{"title":"Uncertain","data":{"":"Uncertain is a cell type that every field of TCell is optional.\nCell of this type will have only one essential field provided by Cell interface - type.","definition#Definition":"type Uncertain<TCell extends Cell> = Partial<TCell> & Cell;"}},"/docs/3.1/7-api/1-types/5-drop-position":{"title":"DropPosition","data":{"":"Indicates where row/column was dropped. Used by ReactGridProps callbacks.","definition#Definition":"type DropPosition = 'before' | 'on' | 'after';"}},"/docs/3.1/7-api/1-types/4-id":{"title":"Id","data":{"":"Id is a common type to identify many objects in grid e.g.:\nHighlight,\nCellLocation,\nCellChange,\nColumn,\nRow\nId can be a number or string.","definition#Definition":"type Id = number | string;"}},"/docs/3.1/7-api/1-types/6-default-cells":{"title":"DefaultCellTypes","data":{"":"ReactGrid API contains a union of basic cells usually used for consuming changes and\nmarking cells array inside the data row.","definition#Definition":"type DefaultCellTypes = CheckboxCell | DateCell | EmailCell | ChevronCell | HeaderCell | NumberCell | TextCell | TimeCell;"}},"/docs/3.1/7-api/1-types/7-selection-mode":{"title":"SelectionMode","data":{"":"ReactGrid API contains three types of values which can be used in selection.\nIt is row, column or range. It's used for marking currect selection mode while\nexecuting exact event.","definition#Definition":"type SelectionMode = 'row' | 'column' | 'range';"}},"/docs/3.1/7-api/2-functions":{"title":"Functions & Enums","data":{"keycodes#Keycodes":"Keycode related functions are commonly used by every cell template and they uses the unicode value of pressed keyboard key\n(exacly like KeyboardEvent.keyCode).\nisAlphaNumericKey(keyCode: number): boolean\nUsed in creating custom cell templates. Checks if keycode is alphanumeric.\ninNumericKey(keyCode: number): boolean\nUsed in creating custom cell templates. Checks if keycode is between 0 and 9 (also on numpad).\nisNumpadNumericKey(keyCode: number): boolean\nUsed in creating custom cell templates. Checks if keycode is between 0 and 9 on numpad.\nisAllowedOnNumberTypingKey(keyCode: number): boolean\nUsed in creating custom cell templates. Checks if keycode is allowed while typing\nnumbers (for chars like comma, dash, period).\nisNavigationKey(keyCode: number): boolean\nUsed in creating custom cell templates. Checks if keycode is allowed for navigation\n(arrows, end, home, backspace, delete keys).\ngetCharFromKeyCode(keyCode: number, isShiftKey: boolean = false): boolean\nConverts key code into char including the Shift key.","helpers#Helpers":"getCellProperty = <TCell extends Cell, TKey extends keyof TCell>(\n    uncertainCell: Uncertain<TCell>,\n    propName: TKey,\n    expectedType: 'string' | 'number' | 'boolean' | 'undefined' | 'function' | 'object' | string\n)\nReturns cell property value. Used to create a compatible cell.","enums#Enums":"keyCodes enum contains a set of key codes + POINTER = 1 to mark a pointer event (ReactGrid addon).\nUsed in cell templates."}},"/docs/4.0":{"title":"4.0","data":{"":"ReactGrid lets you create custom data grids inside your ReactJS applications, which look and feel like spreadsheets.","caveats#Caveats":"a) If you notice sticky incorrect behavior, when you try to pin them to HTML <body> tag, add this line to index.html file in your project.\nIt should be helpful in many cases and different mobile devices.\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=0.86, maximum-scale=5.0, minimum-scale=0.86\">","supported-browsers#Supported browsers":"Desktop Browsers\nMobile Browsers"}},"/docs/4.0/2-implementing-core-features":{"title":"Implementing core features","data":{"":"In this section you will learn about common features of ReactGrid and their example implementations.\nHandling data changes\nColumn resizing\nColumn and row reordering\nSticky rows and columns\nSelections\nFill handle\nContext menu\nGroup Id\nHighlights\nGrouping\nManaging focus\nEmbedding on website\nKeyboard shortcuts\nUndo / Redo feature\nFull width header\nInternationalization\nResponsive sticky headers\nColspan and rowspan cell"}},"/docs/4.0/1-getting-started":{"title":"Getting started","data":{"introduction#Introduction":"In this guide, we're going to build a very simple React App, which will make use of ReactGrid.","initialize-a-react-app-with-reactgrid#Initialize a React App with ReactGrid":"Let's create the basis for our App first:\nnpx create-react-app reactgrid-getting-started --typescript\ncd reactgrid-getting-started\nThe only thing that's missing from our project now is ReactGrid itself.\nTo add it to the dependencies, simply run:\nnpm install @silevis/reactgrid","integrate-reactgrid-into-the-app#Integrate ReactGrid into the App":"Once ReactGrid is installed and ready, we can import it in the following way:\n// App.tsx\nimport * as React from \"react\";\nimport { render } from \"react-dom\";\nimport { ReactGrid, Column, Row } from \"@silevis/reactgrid\";\nimport \"@silevis/reactgrid/styles.css\";\nOur example requires ReactGrid component, two interfaces: Column,\nRow from @silevis/reactgrid and CSS styles from @silevis/reactgrid/styles.css.","define-some-data-to-display-in-the-grid#Define some data to display in the grid":"Although we were able to create an empty ReactGrid, it wouldn't make much sense yet.\nSo let's define some data first, and then feed it into ReactGrid for display.\nWe're going to need two arrays. One for columns prop,\nand the other for rows.\nAt the top of the datatable we are going to display static cells that contain Name and Surname so we can define them now.\nDon't worry about all the properties of columns\nand rows objects now - we'll cover them later on.\ninterface Person {\n  name: string;\n  surname: string;\n}\nconst getPeople = (): Person[] => [\n  { name: \"Thomas\", surname: \"Goldman\" },\n  { name: \"Susie\", surname: \"Quattro\" },\n  { name: \"\", surname: \"\" }\n];\nconst getColumns = (): Column[] => [\n  { columnId: \"name\", width: 150 },\n  { columnId: \"surname\", width: 150 }\n];\nconst headerRow: Row = {\n  rowId: \"header\",\n  cells: [\n    { type: \"header\", text: \"Name\" },\n    { type: \"header\", text: \"Surname\" }\n  ]\n};","generate-your-rows#Generate your rows":"ReactGrid rows prop expects an array of rows that are compatible with imported\nrowss interface.\nAs you see this function returns the header row and mapped people array to ReactGrid's\nRows.\nconst getRows = (people: Person[]): Row[] => [\n  headerRow,\n  ...people.map<Row>((person, idx) => ({\n    rowId: idx,\n    cells: [\n      { type: \"text\", text: person.name },\n      { type: \"text\", text: person.surname }\n    ]\n  }))\n];","pass-the-data-to-reactgrid#Pass the data to ReactGrid":"We've got everything we need to see ReactGrid in action.\nIt's finally time to use the ReactGrid component we imported earlier, and give it the data\nwe defined in the previous steps. This is easy, and can be done like that:\nfunction App() {\n  const [people] = React.useState<Person[]>(getPeople());\n  const rows = getRows(people);\n  return <ReactGrid rows={rows} columns={columns} />;\n}","putting-it-all-together#Putting it all together":"After having followed this guide, your App.tsx file should look more or less like this:\nimport * as React from \"react\";\nimport { render } from \"react-dom\";\nimport { ReactGrid, Column, Row } from \"@silevis/reactgrid\";\nimport \"@silevis/reactgrid/styles.css\";\nimport \"./styles.css\";\ninterface Person {\n  name: string;\n  surname: string;\n}\nconst getPeople = (): Person[] => [\n  { name: \"Thomas\", surname: \"Goldman\" },\n  { name: \"Susie\", surname: \"Quattro\" },\n  { name: \"\", surname: \"\" }\n];\nconst getColumns = (): Column[] => [\n  { columnId: \"name\", width: 150 },\n  { columnId: \"surname\", width: 150 }\n];\nconst headerRow: Row = {\n  rowId: \"header\",\n  cells: [\n    { type: \"header\", text: \"Name\" },\n    { type: \"header\", text: \"Surname\" }\n  ]\n};\nconst getRows = (people: Person[]): Row[] => [\n  headerRow,\n  ...people.map<Row>((person, idx) => ({\n    rowId: idx,\n    cells: [\n      { type: \"text\", text: person.name },\n      { type: \"text\", text: person.surname }\n    ]\n  }))\n];\nfunction App() {\n  const [people] = React.useState<Person[]>(getPeople());\n  const rows = getRows(people);\n  const columns = getColumns();\n  return <ReactGrid rows={rows} columns={columns} />;\n}\nrender(<App />, document.getElementById(\"root\"));\nYou can now start the App locally with:\nnpm start\nOr simply play around with the interactive demo below:","summary#Summary":"You should now have a basic understanding of what ReactGrid is and how it can be used.\nContinue to the next page for more advanced usage examples."}},"/docs/4.0/2-implementing-core-features/3-column-and-row-reordering":{"title":"Column and row reordering","data":{"how-to-implement-column-and-row-reordering#How to implement column and row reordering?":"This guide is based on getting started.","1-update-person-interface-and-people-data#1. Update person interface and people data":"Our Person interface will be extended with the id field. It's necessary to identify person to keep correct order after\nrow reorder action.\ninterface Person {\n  id: number;\n  name: string;\n  surname: string;\n}\nconst getPeople = (): Person[] => [\n  { id: 1, name: \"Thomas\", surname: \"Goldman\" },\n  { id: 2, name: \"Susie\", surname: \"Quattro\" },\n  { id: 3, name: \"\", surname: \"\" },\n];","2-update-column-related-properties#2. Update column related properties":"In our example we will be able to see how to reorder two declared columns.\nWe are currenly working with a column whose application we know everything about.\nLet's define coresponding interface that is personalized stricly to our needs.\ninterface ColumnMap {\n  name: \"Name\";\n  surname: \"Surname\";\n}\nconst columnMap: ColumnMap = {\n  name: \"Name\",\n  surname: \"Surname\",\n};\nReactGrid's Column interface contains columnId property. You can assign any string or even numberto this property.\nIn this example we know that we are working with only name and surname as so we can augment Column\ninterface definition by doing this:\ntype ColumnId = keyof ColumnMap;","3-make-your-columns-reorderable#3. Make your columns reorderable":"This step is simple - just add reorderable: true to the column definitions.\nconst getColumns = (): Column[] => [\n  { columnId: \"name\", width: 150, reorderable: true }, // highlight-line\n  { columnId: \"surname\", width: 200, reorderable: true }, // highlight-line\n];","4-display-rows-with-arbitrary-columns-order#4. Display rows with arbitrary columns order":"In Relation to the base example we need to add one mode argument: columnsOrder.\nThis parameter contains columns key (name or surname) in the same order as we want to display people.\nWe also moved headerRow and replaced it with an object to get a corresponding column title and value of columnMap.\nAlso cells inside mapped people array select persons' attributes in accordance with the order of columns.\nconst getRows = (people: Person[], columnsOrder: ColumnId[]): Row[] => {\n  return [\n    {\n      rowId: \"header\",\n      cells: [\n        { type: \"header\", text: columnMap[columnsOrder[0]] },\n        { type: \"header\", text: columnMap[columnsOrder[1]] },\n      ],\n    },\n    ...people.map<Row>((person, idx) => ({\n      rowId: person.id,\n      reorderable: true,\n      cells: [\n        { type: \"text\", text: person[columnsOrder[0]] }, // `person['name']` / `person['surname']`\n        { type: \"text\", text: person[columnsOrder[1]] }, // `person['surname']` / `person['name']`\n      ],\n    })),\n  ];\n};\nreorderArray function is used to order columns or rows. You can just copy it.\n// a helper function used to reorder arbitrary arrays\nconst reorderArray = <T extends {}>(arr: T[], idxs: number[], to: number) => {\n  const movedElements = arr.filter((_, idx) => idxs.includes(idx));\n  const targetIdx =\n    Math.min(...idxs) < to\n      ? (to += 1)\n      : (to -= idxs.filter((idx) => idx < to).length);\n  const leftSide = arr.filter(\n    (_, idx) => idx < targetIdx && !idxs.includes(idx)\n  );\n  const rightSide = arr.filter(\n    (_, idx) => idx >= targetIdx && !idxs.includes(idx)\n  );\n  return [...leftSide, ...movedElements, ...rightSide];\n};","5-implement-column-and-row-handlers#5. Implement column and row handlers":"All that remains to write is handler for rows and column reordering.\nColumn and row reorder handler is based on searching for destination target index and mapping reordered items to array\nof their occurrence. After that we pass previously mentioned indexes to reorderArray function and update data by calling\nsetColumns and setPeople.\nReactGrid component needs to have enabled enableRowSelection and enableColumnSelection.\nconst ColumnsAndRowsReorderSample = () => {\n  const [people, setPeople] = React.useState<Person[]>(getPeople());\n  const [columns, setColumns] = React.useState<Column[]>(getColumns());\n  const rows = getRows(\n    people,\n    columns.map((c) => c.columnId as ColumnId)\n  );\n  const handleColumnsReorder = (targetColumnId: Id, columnIds: Id[]) => {\n    const to = columns.findIndex(\n      (column) => column.columnId === targetColumnId\n    );\n    const columnIdxs = columnIds.map((columnId) =>\n      columns.findIndex((c) => c.columnId === columnId)\n    );\n    setColumns((prevColumns) => reorderArray(prevColumns, columnIdxs, to));\n  };\n  const handleRowsReorder = (targetRowId: Id, rowIds: Id[]) => {\n    setPeople((prevPeople) => {\n      const to = people.findIndex((person) => person.id === targetRowId);\n      const rowsIds = rowIds.map((id) =>\n        people.findIndex((person) => person.id === id)\n      );\n      return reorderArray(prevPeople, rowsIds, to);\n    });\n  };\n  return (\n    <ReactGrid\n      rows={rows}\n      columns={columns}\n      onColumnsReordered={handleColumnsReorder}\n      onRowsReordered={handleRowsReorder}\n      enableRowSelection\n      enableColumnSelection\n    />\n  );\n};","bonus---preventing-dropping-rows-on-unwanted-location#Bonus - preventing dropping rows on unwanted location":"This 'feature' can be done by making handleCanReorderRows function and passing it to canReorderRows ReactGrid prop.\nWe also provided canReorderColumns prop that can do the same thing, but with columns.While you reorder a row you can see the line that is visible above the header row. We probably don't want to mislead the end user\nwho might drop the row over there.When you drop row then your handleCanReorderRows is called. We can define that dropping over the row whose rowId field equals\nheader is prohibited. In this case you won't see reorder line indication and handleRowsReorder is not called by default.\nconst handleCanReorderRows = (targetRowId: Id, rowIds: Id[]): boolean => {\n  return targetRowId !== \"header\";\n};\nconst ColumnsAndRowsReorderSample = () => {\n  // ...\n  return (\n    <ReactGrid\n      rows={rows}\n      columns={columns}\n      onColumnsReordered={handleColumnsReorder}\n      onRowsReordered={handleRowsReorder}\n      enableRowSelection\n      enableColumnSelection\n      canReorderRows={handleCanReorderRows} // highlight-line\n    />\n  );\n};","live-demo#Live demo":""}},"/docs/4.0/2-implementing-core-features/4-sticky":{"title":"Sticky rows and columns","data":{"introduction#Introduction":"ReactGrid allows you to stick chosen rows and columns at the top or left side and additionally on the right and at the bottom\nof the ReactGrid viewport. Sticky rows or columns will be visible at all times, no matter what the scroll position is.Sticky rows and columns can be enabled by adding dedicated ReactGrid component properties:\nstickyTopRows\nstickyBottomRows\nstickyLeftColumns\nstickyRightColumns\nAll of these properties are numeric and determine the number of columns or rows sticky next to the grid's edges.","how-to-make-columns-and-rows-sticky#How to make columns and rows sticky?":"This guide is based on getting started.\nUpdate Person interface and then add some more data to the table, so that it's more likely for a scrollbar to appear\nor reduce the height of the grid container.\ninterface Person {\n    name: string;\n    surname: string;\n    birth: Date | undefined; // highlight-line\n    mobile: number; // highlight-line\n    company: string; // highlight-line\n    occupation: string; // highlight-line\n}\nconst getPeople = (): Person[] => [\n    {\n        name: \"Thomas\",\n        surname: \"Goldman\",\n        birth: new Date(\"1970-12-02\"), // highlight-line\n        mobile: 574839457, // highlight-line\n        company: \"Snatia Ebereum\", // highlight-line\n        occupation: \"CEO\" // highlight-line\n    },\n    {\n        name: \"Mathew Lawrence\",\n        surname: \"Joshua\",\n        birth: new Date(\"1943-12-02\"), // highlight-line\n        mobile: 684739283, // highlight-line\n        company: \"De-Jaiz Mens Clothing\", // highlight-line\n        occupation: \"Technical recruiter\" // highlight-line\n    },\n    {\n        name: \"Susie Evelyn\",\n        surname: \"Spencer\",\n        birth: new Date(\"1976-01-23\"), // highlight-line\n        mobile: 684739283, // highlight-line\n        company: \"Harold Powell\", // highlight-line\n        occupation: \"Concrete paving machine operator\" // highlight-line\n    },\n    {\n        name: \"\",\n        surname: \"\",\n        birth: undefined, // highlight-line\n        mobile: NaN, // highlight-line\n        company: \"\", // highlight-line\n        occupation: \"\" // highlight-line\n    }\n];\nconst getColumns = (): Column[] => [\n    { columnId: \"Name\", width: 150 },\n    { columnId: \"Surname\", width: 100 },\n    { columnId: \"Birth Data\", width: 100 }, // highlight-line\n    { columnId: \"Phone\", width: 100 }, // highlight-line\n    { columnId: \"Company\", width: 150 }, // highlight-line\n    { columnId: \"Occupation\", width: 230 } // highlight-line\n];\nUse the properties mentioned in the introduction to set the number of sticky ranges at each edge\nreturn (\n\t<ReactGrid\n\t\trows={rows}\n\t\tcolumns={columns}\n\t\tstickyLeftColumns={1} // highlight-line\n\t\tstickyRightColumns={1} // highlight-line\n\t\tstickyTopRows={1} // highlight-line\n\t\tstickyBottomRows={1} // highlight-line\n\t/>\n);","result#Result":"Here's how sticky rows and columns look in action (we recommend playing with this demo in the fullscreen mode):"}},"/docs/4.0/2-implementing-core-features/1-handling-changes":{"title":"Handling data changes","data":{"idea-of-handling-data-changes#Idea of handling data changes":"A user changes the value of a cell. Among others, it could mean that the user has:\ncommitted a new value into a cell by cell editor,\nused a fill handle,\npasted some data into the cell matrix,\ninteracted with a clickable cell (e. g. expanded chevron cell).\nReactGrid fires the onCellsChanged event\nYour handler function processes the event and updates the data\nThe ReactGrid component receives new data and gets rerendered\nBy default, the data grid will behave as if it was in a \"read-only\" mode.\nTo support dynamic data editing, you will have to handle the onCellsChanged event yourself.","when-is-my-handler-function-called#When is my handler function called?":"Changes have been committed after cell editing.\nAfter pasting with the shortcut or the context menu.\nAfter fill handle action.","handling-changes-in-your-project#Handling changes in your project":"This part is based on getting started.Let's start with updating imports:\nimport {\n  ReactGrid,\n  Column,\n  Row,\n  CellChange,\n  TextCell,\n} from \"@silevis/reactgrid\";","sample-change-handler-function#Sample change handler function":"The function receives an array describing all of the changes made to the data grid's cells and data on the basis of which\nReactGrid's rows were generated.\nWe expect that the incoming changes affect TextCell, so the changes were marked by a following interface: CellChange<TextCell>[].\nGiven that information, we find the row and the column affected by each change,\nand then replace an appropriate cell text with a new one.\nWe can declare a basic handler function like this:\nconst applyChangesToPeople = (\n  changes: CellChange<TextCell>[],\n  prevPeople: Person[]\n): Person[] => {\n  changes.forEach((change) => {\n    const personIndex = change.rowId;\n    const fieldName = change.columnId;\n    prevPeople[personIndex][fieldName] = change.newCell.text;\n  });\n  return [...prevPeople];\n};\nLet's pass the handler function to our ReactGrid component:\nfunction App() {\n  const [people, setPeople] = React.useState<Person[]>(getPeople());\n  const rows = getRows(people);\n  const columns = getColumns();\n  const handleChanges = (changes: CellChange<TextCell>[]) => {\n    setPeople((prevPeople) => applyChangesToPeople(changes, prevPeople));\n  };\n  return (\n    <ReactGrid rows={rows} columns={columns} onCellsChanged={handleChanges} />\n  );\n}","live-demo#Live demo":"And here's an interactive demo showing the event handler in action.\nNotice how it is now possible to edit the data not only by typing new values into the cells,\nbut also by using the fill handle or by pasting data from the clipboard."}},"/docs/4.0/2-implementing-core-features/2-column-resizing":{"title":"Column resizing","data":{"allow-column-to-be-resized#Allow column to be resized":"For each column which should be resizable, add the resizable property\nto the corresponding column object and set its value to true.\nconst getColumns = (): Column[] => [\n  { columnId: \"name\", width: 150, resizable: true }, //highlight-line\n  { columnId: \"surname\", width: 150, resizable: true }, //highlight-line\n];\nIf you hover over the vertical border line between the column headers,\nyou will see your mouse pointer change to indicate that a column can be resized.\nHowever, you'll quickly notice that the column resizing functionality doesn't work.\nWhy is that? We still need to handle the events fired by ReactGrid when a column is being resized.\nSimilar to how we handled data changes in handling changes,\nwe can also define a handler function for that and pass it to our ReactGrid component.","usestate-hook-for-columns-storing#useState hook for columns storing":"function App() {\n  const [people] = React.useState<Person[]>(getPeople());\n  const [columns, setColumns] = React.useState<Column[]>(getColumns()); //highlight-line\n  const rows = getRows(people);\n  return <ReactGrid rows={rows} columns={columns} />;\n}","implement-the-handler-function#Implement the handler function":"handleColumnResize handles the event when its finished. Knowing the column Id and its new width, we can apply\nchanges by calling setColumns function and returning array of updated columns (width/widths).\nfunction App() {\n  const [people] = React.useState<Person[]>(getPeople());\n  const [columns, setColumns] = React.useState<Column[]>(getColumns());\n  const rows = getRows(people);\n  const handleColumnResize = (ci: Id, width: number) => {\n    setColumns((prevColumns) => {\n      const columnIndex = prevColumns.findIndex((el) => el.columnId === ci);\n      const resizedColumn = prevColumns[columnIndex];\n      const updatedColumn = { ...resizedColumn, width };\n      prevColumns[columnIndex] = updatedColumn;\n      return [...prevColumns];\n    });\n  };\n  return (\n    <ReactGrid\n      rows={rows}\n      columns={columns}\n      onColumnResized={handleColumnResize}\n    />\n  );\n}","live-demo#Live demo":"Let's check the results:"}},"/docs/4.0/2-implementing-core-features/4a-selections":{"title":"Selections","data":{"introduction#Introduction":"ReactGrid has three properties related to selections inside the grid via ReactGrid:\nenableRangeSelection\nenableRowSelection\nenableColumnSelection","enablerangeselection-property#enableRangeSelection property":"The range selection is the most common selection, but in case you want to use it, it's necessary to enable it before.\nYou can do multiple selections by holding the Ctrl or Command ⌘ key on Apple devices.\n<ReactGrid\n    {...props}\n    enableRangeSelection //highlight-line\n/>","enablerowselection-and-enablecolumnselection-property#enableRowSelection and enableColumnSelection property":"Way how enableRowSelection and enableColumnSelection property works is very similar.When you first click on:\nthe left cell of a row, the whole row will be selected, then you can expand this selection to other rows;\nthe top cell of the column, the whole column will be selected, then you can expand this selection to other columns.\nYou can then select or unselect any row/column by Ctrl or Command ⌘ key.If you click on the first top-left cell and enableColumnSelection is enabled then the column has a priority\nover the row in this particular case.\n<ReactGrid\n    {...props}\n    enableRowSelection //highlight-line\n    enableColumnSelection //highlight-line\n/>"}},"/docs/4.0/2-implementing-core-features/4b-fill-handle":{"title":"Fill handle","data":{"about-fill-handling-in-reactgrid#About fill handling in ReactGrid":"ReactGrid supports fill handle action, but it is disabled by default. To turn it on you have to simply\nadd enableFillHandle property to ReactGrid component. Now you are able to use autocomplete feature by default.\nThis feature allows you to set further values to be filled in based on the data contained in the selection. Otherwise, the data is repeated\nrespective to the direction. Data isn't predicted when ctrl key is pressed (or Option/⌥ key on Apple devices).\n<ReactGrid\n    {...props}\n    enableFillHandle //highlight-line\n/>\nNote that if an incoming change will not be handled by the app, then there will be no visible changes,\nthough the action was correctly performed."}},"/docs/4.0/2-implementing-core-features/5a-groupId":{"title":"Group Id","data":{"what-is-group-id#What is group id?":"ReactGrid introduces a brand new feature called group Id. The main purpose of it is to avoid queueing changes\nby marking cells on groupId property using Id interface.Marked cell with a groupId has a following behavior. While you paste data or execute fill handle action: the change will\nbe queued only for a cell with the same groupId. If the change can't be queued, then you will be warned in browser's console.\nEven if no cell is marked, then they are treated as a separate group.Every cell with declared groupId renders with additional span element (containing its value) inside a cell if\nyou have passed enableGroupIdRender property:\n<ReactGrid\n    {...props}\n    enableFillHandle\n    enableRangeSelection\n    enableGroupIdRender // highlight-line\n/>\ngroupId property is available in every cell template because it's provided by Cell\ninterface.","live-example#Live example":"An example shows that a few cells were marked with group: A or group: B group Id.\nTry and select any range and then copy and paste or use fill handle to clone data."}},"/docs/4.0/2-implementing-core-features/5-context-menu":{"title":"Context menu","data":{"introduction#Introduction":"ReactGrid comes with a custom context menu feature. Custom menu entries can be easily created thus\nallowing for personalized experiences.\nBy default, the context menu is disabled. You can enable it by providing a handler function\nto your ReactGrid using the onContextMenu property.","enabling-simple-context-menu#Enabling simple context menu":"This guide is based on handling data changes.\nUpdate imports by adding Id, SelectionMode\nand MenuOption interfaces.\nimport { ReactGrid, CellChange, Row, Column, Id, MenuOption, SelectionMode } from \"@silevis/reactgrid\";\nImplement the context menu handler function\nThe menuOptions argument of simpleHandleContextMenu contains a list of default menu entries\nprovided by ReactGrid - copy, cut and paste.\nFor now, we'll simply define it, which will enable the default ReactGrid context menu.\nconst [people, setPeople] = React.useState<Person[]>(getPeople());\n  const rows = getRows(people);\n  const columns = getColumns();\n  const handleChanges = (changes: CellChange[]) => {\n    setPeople((prevPeople) => applyChangesToPeople(changes, prevPeople));\n  };\n  const simpleHandleContextMenu = (\n    selectedRowIds: Id[],\n    selectedColIds: Id[],\n    selectionMode: SelectionMode,\n    menuOptions: MenuOption[]\n  ): MenuOption[] => {\n    return menuOptions;\n  }\n  return (\n    <ReactGrid\n      rows={rows}\n      columns={columns}\n      onCellsChanged={handleChanges}\n      onContextMenu={simpleHandleContextMenu}\n    />\n  );\nHere's the result. Right-click anywhere in the grid to see the context menu.","advanced-example---removing-columns-and-rows#Advanced example - removing columns and rows":"The default menu, though pretty, may seem a bit lacklustre when it comes to the functionality it provides.\nLet's try and extend it a bit - we'll make it possible to remove people using the context menu.\nImplement a more advanced context menu handler function.\nconst handleContextMenu = (\n  selectedRowIds: Id[],\n  selectedColIds: Id[],\n  selectionMode: SelectionMode,\n  menuOptions: MenuOption[]\n): MenuOption[] => {\n  if (selectionMode === \"row\") {\n    menuOptions = [\n      ...menuOptions,\n      {\n        id: \"removePerson\",\n        label: \"Remove person\",\n        handler: () => {\n          setPeople(prevPeople => {\n            return [...prevPeople.filter((person, idx) => !selectedRowIds.includes(idx))]\n          })\n        }\n      }\n    ];\n  }\n  return menuOptions;\n}\nUpdate the ReactGrid component's properties. Note that rows must be selectable for our feature to work.\nAfter all, we will be removing the currently selected rows.\nreturn (\n  <ReactGrid\n    rows={rows}\n    columns={columns}\n    onCellsChanged={handleChanges}\n    onContextMenu={handleContextMenu}\n    enableFillHandle\n    enableRangeSelection\n    enableRowSelection\n  />\n)","live-demo#Live demo":"You can see the effect of the changes we've just introduced in the demo below.\nTo test the new feature, simply select a row by clicking a header cell or one of the leftmost cells,\nthen right-click anywhere and use the new menu entry."}},"/docs/4.0/2-implementing-core-features/7-managing-focus":{"title":"Focus management","data":{"focus-locations#Focus locations":"ReactGrid has two properties related to focus location inside the grid via ReactGrid:\nfocusLocation\ninitialFocusLocation","initialfocuslocation-property#initialFocusLocation property":"You can set focus location at the first render of ReactGrid. Then this property is used no more.\n<ReactGrid\n    {...props}\n    initialFocusLocation={{ columnId: 'col-2', rowId: 'row-2' }} //highlight-line\n/>","focuslocation-property#focusLocation property":"Defining focusLocation property is superior to pointer and keyboard actions, so you have to manage it all over time.\nIf focusLocation property has falsy value then it is ignored.\nDefined initialFocusLocation is immediately overridden by focusLocation\n<ReactGrid\n    {...props}\n    initialFocusLocation={{ columnId: 'col-3', rowId: 'row-3' }} //highlight-line\n    focusLocation={{ columnId: 'col-2', rowId: 'row-2' }} //highlight-line\n/>"}},"/docs/4.0/2-implementing-core-features/6-highlights":{"title":"Highlights","data":{"highlights-usage#Highlights usage":"This guide is based on getting started.Highlights allow you to alter arbitrary cells in the grid\nby applying custom CSS classes to them or by setting their border colours.\nImport the Highlight interface\nimport { ReactGrid, Highlight } from \"@silevis/reactgrid\";\nDefine an array of Highlight objects\nconst highlights: Highlight[] = [\n  { columnId: \"Name\", rowId: 1, borderColor: \"#00ff00\" },\n  { columnId: \"Surname\", rowId: 2, borderColor: \"#0000ff\" },\n  { columnId: \"Name\", rowId: 3, borderColor: \"#ff0000\" }\n];\nPass the highlights object array to your component\nreturn <ReactGrid rows={rows} columns={columns} highlights={highlights} />;","live-demo#Live demo":""}},"/docs/4.0/2-implementing-core-features/8-embedding-on-website":{"title":"Embedding on a website","data":{"about-reactgrig-embedding-virtual-scrolling-and-sticky-panes-pinning#About ReactGrig embedding, virtual scrolling and sticky panes pinning":"ReactGrid component isn't limited by height and width so its behaviour can change a little bit depending on its scrollable parent element.ReactGrid appends scroll event to its immediate scrollable parent and lets itself expand to full height/width with the option of\nconstant observation of available viewport size.Limiting the size of ReactGrid can be achieved by adding CSS class listed below\n(bear in mind that the total rows height must be bigger than scrollable element height)\n.reactgrid-wrapper {\n    height: 100px;\n    overflow: scroll;\n}\nMultiple nested scrollable elements can cause unexpected experience like incorrect cell editor position, wrong focus location etc.\nIf all rows/columns can't be rendered in viewport - virtual scrolling still works fine.","example-reactgrid-component-limited-by-the-height-of-its-parent#Example: ReactGrid component limited by the height of its parent":"In this case, not all the passed rows can be rendered, so scrollbar appears and sticky pane is pinned directly to the top of the\nparent element.","example-reactgrid-component-not-limited-by-the-height-of-its-parent#Example: ReactGrid component NOT limited by the height of its parent":"ReactGrid renders all the passed rows and columns if sticky panes are passed - they are pinned directly to the edge\nof body element."}},"/docs/4.0/2-implementing-core-features/9-keyboard-shortcuts":{"title":"Keyboard shortcuts","data":{"about-keyboard-events#About keyboard events":"ReactGrid allows you to interact with the grid using keyboard shortcuts in a way known from other spreadsheet-like apps.At this moment we plan to add few callback events for clipboard action like copying, pasting and cutting.","keyboard-shortcuts#Keyboard shortcuts":"Shortcut\tAction\t↑\tMoves cell focus one cell up (if is focusable)\t↓\tMoves cell focus one cell down (if is focusable)\t←\tMoves cell focus to the left (if is focusable)\t→\tMoves cell focus to the right (if is focusable)\tEnter\tOpens cell editor if cell is focused or moves focus down inside range selection\tDelete or Backspace\tWipe selected range or only focused location\tTab\tMoves focus to the right if single cell is selected or moves focus to the right inside range selection\tHome\tMoves focus to the first column\tEnd\tMoves focus to the last column\tPageUp\tMoves focus up by one page (visible number of rows)\tPageDown\tMoves focus down by one page (visible number of rows)\tEscape\tAborts cell edition without changing it\tCtrl + Space\tExpands selection in vertical direction (only on Apple devices)\tCtrl  + Shift + Home or  ⌘ + Shift + Home\tSelects all cells above currect selection\tCtrl + Shift + End or  ⌘ + Shift +  End\tSelects all cells below currect selection\t⌘ + A or Ctrl + A\tSelects all cells\t⌘ + Home or Ctrl + Home\tSelects top left cell\t⌘ + End or Ctrl + End\tSelects bottom right cell\tCtrl + End\tSelect whole column on Windows\tShift + Enter\tCloses cell editor if it is opened and moves focus cell above last edited cell\tShift + ↑\tSelects one cell above\tShift + ↓\tSelects one cell below\tShift + ←\tSelects one cell on the left\tShift + →\tSelects one cell on the right\tShift + Tab\tMoves focus to the left if single cell is selected or moves focus to the left inside range selection\tShift + Enter\tMoves focus one cell above if single cell is selected or moves focus up inside range selection\tShift + Space\tExpands selection in vertical direction (from top to bottom)\tShift + Home\tExpands selection to the first column\tShift + End\tExpands selection to the last column\tShift + PageUp\tIncrease or decrease selection by single page\tShift + PageDown\tIncrease or decrease selection by single page"}},"/docs/4.0/2-implementing-core-features/9a-undo-redo-feature":{"title":"Undo/redo feature","data":{"idea-of-undoredo-feature#Idea of Undo/redo feature":"An Undo/Redo feature isn't implemented internally, but we prepared an example which you can follow.\nReactGrid bypasses undo and redo events.\nYou can handle onKeyDown event to use your own implemented Undo/Redo feature.\nThe ReactGrid component receives revoked or restored data and gets rerendered.\nIt's possible to use with Ctrl + z and Ctrl + y keyboard shortcuts or prepared by you buttons.","when-are-my-handler-functions-called#When are my handler functions called?":"Changes have been committed after Ctrl + z and Ctrl + y key.\nChanges have been committed after Undo and Redo button.","implementing-feature-in-your-project#Implementing feature in your project":"This feature develops handling changes example.Let's start with updating imports:\nimport {\n  ReactGrid,\n  Column,\n  Row,\n  CellChange,\n  TextCell,\n} from \"@silevis/reactgrid\";","sample-undoredo-feature#Sample Undo/Redo feature":"For this reason we prepared special functions, which you can use in your project and adjust to it.\nWe have an array of changes made by the user at each step. The place in the history of changes, where you currently are, is stored.\nLook at this function:\nconst applyNewValue = (\n  changes: CellChange<TextCell>[],\n  prevPeople: Person[],\n  usePrevValue: boolean = false\n): Person[] => {\n  changes.forEach((change) => {\n    const personIndex = change.rowId;\n    const fieldName = change.columnId;\n    const cell = usePrevValue ? change.previousCell : change.newCell;\n    prevPeople[personIndex][fieldName] = cell.text;\n  });\n  return [...prevPeople];\n};\nFunction applyChangesToPeople is a similar function which is responsible for handling changes.\nAdditionally we need to store all the changes and the index of changes, which will help us to move within the changes array.\nconst applyChangesToPeople = (\n  changes: CellChange<TextCell>[],\n  prevPeople: Person[]\n): Person[] => {\n  const updated = applyNewValue(changes, prevPeople);\n  setCellChanges([...cellChanges.slice(0, cellChangesIndex + 1), changes]);\n  setCellChangesIndex(cellChangesIndex + 1);\n  return updated;\n};\nThe undoChanges function allows you to set the previous value and change the index in the appropriate place in the array.\nThe change index is moved one step backwards.\nconst undoChanges = (\n  changes: CellChange<TextCell>[],\n  prevPeople: Person[]\n): Person[] => {\n  const updated = applyNewValue(changes, prevPeople, true);\n  setCellChangesIndex(cellChangesIndex - 1);\n  return updated;\n};\nThe redoChanges function allows you to set the restored change. Change index also has to be moved one position forward.\nconst redoChanges = (\n  changes: CellChange<TextCell>[],\n  prevPeople: Person[]\n): Person[] => {\n  const updated = applyNewValue(changes, prevPeople);\n  setCellChangesIndex(cellChangesIndex + 1);\n  return updated;\n};\nLet's use the above functions inside an example App component. We added two hooks inside it:\nconst [cellChangesIndex, setCellChangesIndex] = React.useState(() => -1);\nconst [cellChanges, setCellChanges] = React.useState<CellChange<TextCell>[][]>(\n  () => []\n);\nThe first one stores current index of changes for the second hook - storing an array of changes that has affected\nthe TextCells.We have wrapped ReactGrid with div element that listens to onKeyDown event.\nChanges can be also restored/redone with two buttons.Inside both methods (handleUndoChanges and handleRedoChanges) we update our data - poople array.\nThese changes come from cellChanges array.\nfunction App() {\n  const [people, setPeople] = React.useState<Person[]>(getPeople());\n  const [cellChangesIndex, setCellChangesIndex] = React.useState(() => -1);\n  const [cellChanges, setCellChanges] = React.useState<\n    CellChange<TextCell>[][]\n  >(() => []);\n  const rows = getRows(people);\n  const columns = getColumns();\n  const handleChanges = (changes: CellChange<TextCell>[]) => {\n    setPeople((prevPeople) => applyChangesToPeople(changes, prevPeople));\n  };\n  const handleUndoChanges = () => {\n    if (cellChangesIndex >= 0) {\n      setPeople((prevPeople) =>\n        undoChanges(cellChanges[cellChangesIndex], prevPeople)\n      );\n    }\n  };\n  const handleRedoChanges = () => {\n    if (cellChangesIndex + 1 <= cellChanges.length - 1) {\n      setPeople((prevPeople) =>\n        redoChanges(cellChanges[cellChangesIndex + 1], prevPeople)\n      );\n    }\n  };\n  return (\n    <div\n      onKeyDown={(e) => {\n        if ((!isMacOs() && e.ctrlKey) || e.metaKey) {\n          switch (e.key) {\n            case \"z\":\n              handleUndoChanges();\n              return;\n            case \"y\":\n              handleRedoChanges();\n              return;\n          }\n        }\n      }}\n    >\n      <ReactGrid rows={rows} columns={columns} onCellsChanged={handleChanges} />\n      <button onClick={handleUndoChanges}>Undo</button>\n      <button onClick={handleRedoChanges}>Redo</button>\n    </div>\n  );\n}","live-demo#Live demo":"And here's an interactive demo showing the Undo / Redo feature."}},"/docs/4.0/2-implementing-core-features/9b-full-width-header":{"title":"Full width header","data":{"introduction#Introduction":"Full width header feature is experimental and it can be changed in the future\nThis feature extends width of top sticky pane to full available space inside ReactGrid's parent.","usage#Usage":"Add enableFullWidthHeader property to ReactGrid component and add any number of stickyTopRows. In our example, the sample\nReactGrid component was also wrapped inside a div element that is wider than all columns.\nreturn (\n  <div style={{ width: \"1200px\", height: \"200px\" }}>\n    <ReactGrid\n      rows={rows}\n      columns={columns}\n      enableFullWidthHeader\n      stickyTopRows={1}\n    />\n  </div>\n);","#":"","issues#Issues":"If the width of ReactGrid's parent is less then the sum of all the columns (including left sticky), there might be bugs\nenabling right and bottom sticky panes can cause bugs related with scrolling, ranges selection etc."}},"/docs/4.0/2-implementing-core-features/9d-responsive-sticky":{"title":"Responsive sticky","data":{"introduction#Introduction":"This feature disables sticky when the sum of the sizes of sticky panes overflows given breakpoint value (by default 50).","usage#Usage":"The feature is enabled by default. If you want to change the breakpoints value you can add horizontalStickyBreakpoint or\nverticalStickyBreakpoint property to ReactGrid component.In this example, sticky will disable when their width or height will be more than 40% of the viewport.\nreturn (\n  <div style={{ width: \"100vw\", height: \"100vh\" }}>\n    <ReactGrid\n      {...props}\n      stickyLeftColumns={3}\n      stickyTopRows={5}\n      horizontalStickyBreakpoint={40} \n      verticalStickyBreakpoint={40}\n    />\n  </div>\n);"}},"/docs/4.0/2-implementing-core-features/9c-internationalization":{"title":"Internationalization","data":{"adding-i18n#Adding i18n":"ReactGrid has a few optional text labels that you could replace. All of the available translations are defined in\nTextLabels interface. You can create an object, and then pass it to labels\nproperty.\nreturn (\n\t<ReactGrid\n    {...props}\n    labels={{\n        copyLabel: 'Copy me!',\n        pasteLabel: 'Paste me!',\n        cutLabel: 'Cut me!',\n    }}\n\t/>\n);","locale-inside-cell-templates#Locale inside cell templates":"Some cell templates (NumberCell, DateCell,\nTimeCell) contain inside optional format field. This field uses\nIntl object of ECMAScript Internationalization API.\nWe suggest formatting cells content via mentioned API."}},"/docs/4.0/4-cell-templates/2-CheckboxCell":{"title":"CheckboxCell","data":{"":"This cell type displays checkbox input. This template has disabled edit mode.","implementation#Implementation":"Open CheckboxCell implementation on  github","interface-declaration#Interface declaration":"interface CheckboxCell extends Cell {\n    type: 'checkbox';\n    checked: boolean;\n    checkedText?: string;\n    uncheckedText?: string;\n}\nProperty name\tType\tProperty description\ttype\tcheckbox\tType of cell template\tchecked\tboolean\tCurrent state of checked attribute in input element\tcheckedText?\tstring\tText of \"checked text input\", used while getting compatible cell, by default: 1\tuncheckedText?\tstring\tText of \"unchecked text input\",  used while getting compatible cell, by default: `` (empty string)"}},"/docs/4.0/2-implementing-core-features/9e-cell-span":{"title":"Cell span","data":{"introduction#Introduction":"This feature is experimental, incomplete and can be changed in the future.\nThis feature allows you to set colspan and rowspan in a cell. Spanned cell don't pushes the other from their origin position.\nInsted, spanned cell stretches to desired size.","usage#Usage":"If you want to use it, please use only cells which type is header.\nThe use of this type of cell results in less undesirable behavior.\nCells that lie underneath the spanned cell should also be  marksed as header type.\nimport { Row } from \"@silevis/reactgrid\";\nconst row: Row = {\n    rowId: 0,\n    cells: [\n       { type: 'header', text: 'total', colspan: 3}, // highlight-line\n       { type: 'header', text: '' }, // highlight-line\n       { type: 'header', text: '' }, // highlight-line\n       { type: 'text', text: 'some text'},\n      // ...\n    ]\n}","caveats#Caveats":"Currently, the span of cells plays a visual role, functionalities related to interaction will be successively implemented\nin the future.\nFeature\tSupport\tDisplaying\t🟢\tHighlights\t🟢\tKeyboard actions\t🟠\tFocus\t🔴\tCell editor\t🔴\tCopy/cut/paste\t🔴\tSelection\t🔴\tFill handle\t🔴\tScrolling\t🔴"}},"/docs/4.0/4-cell-templates/3a-DropdownCell":{"title":"DropdownCell","data":{"":"This cell renders dropdown from react-select package.Note: Visibility of the dropdown is controlled by the isOpen prop.","implementation#Implementation":"Open DropdownCell implementation on Github","interface-declaration#Interface declaration":"type OptionType = {\n  label: string;\n  value: string;\n};\ninterface DropdownCell extends Cell {\n  type: \"dropdown\";\n  selectedValue?: string;\n  values: OptionType[];\n  isDisabled?: boolean;\n  isOpen?: boolean;\n  inputValue?: string;\n}\nProperty name\tType\tProperty description\ttype\tdropdown\tType of cell template\tselectedValue\t?string\tCurrently selected option\tvalues?\tOptionType[]\tAn array of options\tisDisabled?\t?boolean\tDisables dropdown from opening\tisOpen?\t?boolean\tControls current state of open/close\tinputValue?\t?string\tA value typed into a dropdown filter"}},"/docs/4.0/4-cell-templates/4-cell-templates":{"title":"Cell templates","data":{"idea-of-cell-templates#Idea of cell templates":"In getting started chapter we declared cells array to be part of ReactGrid property.Each cell template has its own and unique behavior, content formatting and styling.Nothing stops you from creating your custom cell - read about creating your own cell template.In the listing below we declared two cells of header type, and they are related to the interface of HeaderCell\ntemplate.\ncells: [\n    { type: \"header\", text: \"Name\" },\n    { type: \"header\", text: \"Surname\" }\n]\nEvery cell object must contain type attribute, other keys depend on the exact type of a specific cell.","builtin-cell-templates#Builtin cell templates":"CheckboxCell\nDateCell\nDropdownCell\nEmailCell\nChevronCell\nHeaderCell\nNumberCell\nTextCell\nTimeCell"}},"/docs/4.0/4-cell-templates/3-DateCell":{"title":"DateCell","data":{"":"This template formats Date object and displays default browser date picker in edit mode.","implementation#Implementation":"Open DateCell implementation on  github","interface-declaration#Interface declaration":"interface DateCell extends Cell {\n    type: 'date';\n    date?: Date;\n    format?: Intl.DateTimeFormat;\n}\nProperty name\tType\tProperty description\ttype\tdate\tType of cell template\tdate?\tDate\tDate object, optional\tformat?\tIntl.DateTimeFormat\tFormats date, if undefined formats date according to the currect browser locale"}},"/docs/4.0/4-cell-templates/4-EmailCell":{"title":"EmailCell","data":{"":"This cell renders text value with the possibility to validate its value and wrap the result into React.ReactNode objects.","implementation#Implementation":"Open EmailCell implementation on  github","interface-declaration#Interface declaration":"interface EmailCell extends Cell {\n  type: \"email\"\n  text: string\n  validator?: (text: string) => boolean\n  renderer?: (text: string) => React.ReactNode\n}\nProperty name\tType\tProperty description\ttype\temail\tType of cell template\ttext\tstring\tText content of cell\tvalidator?\t(text: string) => boolean\tOptional validation function, if undefined - returns true\trenderer?\t(text: string) => React.ReactNode\tOptional, gives oportunity to wrap text property into any ReactNode object"}},"/docs/4.0/4-cell-templates/5-ChevronCell":{"title":"ChevronCell","data":{"":"ChevronCell contains data about a single node in the tree structure of the data. This cell template renders text with\nthe preceding chevron.Implementation of grouping functionality remains on developer (e.g., creating tree structure of cells,\nfiltering rows available to display, creating indents).hasChildren field is necessary to display ChevronCell.","implementation#Implementation":"Open ChevronCell implementation on  github","interface-declaration#Interface declaration":"interface ChevronCell extends Cell {\n    type: 'chevron';\n    text: string;\n    isExpanded?: boolean;\n    hasChildren?: boolean;\n    parentId?: Id;\n    indent?: number;\n}\nProperty name\tType\tProperty description\ttype\tchevron\tType of cell template\ttext\tstring\tText of cell content\tisExpanded?\tboolean\tIs node expaned (displays chevron char as opened/closed)\thasChildren?\tboolean\tDetermines if a node element has children\tparentId?\tId\tId of parent node (cell), if undefined the node becomes a root\tindent?\tnumber\tIndent size of cell content"}},"/docs/4.0/4-cell-templates/6-HeaderCell":{"title":"HeaderCell","data":{"":"The main purpose of this cell is to mark its content as not focusable and read-only. Usually used to mark header rows\nand columns. HeaderCell also prevents scroll action (it's helpfull on a touch screens to perform row and column selection).\nHeaderCell interface is extended by Span, therefore you can span this cell.","implementation#Implementation":"Open HeaderCell implementation on  github","interface-declaration#Interface declaration":"interface HeaderCell extends Cell, Span {\n    type: 'header';\n    text: string;\n}\nProperty name\tType\tProperty description\ttype\theader\tType of cell template\ttext\tstring\tContent of cell"}},"/docs/4.0/4-cell-templates/7-NumberCell":{"title":"NumberCell","data":{"":"Displays number, this cell allows to customize format number values using Intl.NumberFormat.","implementation#Implementation":"Open NumberCell implementation on  github","interface-declaration#Interface declaration":"interface NumberCell extends Cell {\n    type: 'number';\n    value: number;\n    format?: Intl.NumberFormat;\n    nanToZero?: boolean;\n    hideZero?: boolean;\n}\nProperty name\tType\tProperty description\ttype\theader\tType of cell template\tvalue\tnumber\tValue of cell\tformat?\tIntl.NumberFormat\tFormats value, if undefined formats number according to currect browser locale\tnanToZero?\tboolean\tIf value equals NaN then displays 0\thideZero?\tboolean\tIf displayed value equals 0 then value is not rendered"}},"/docs/4.0/4-cell-templates/8-TextCell":{"title":"TextCell","data":{"":"This template allows to display text as a string value. Optionally it also gives\na possibility to change rendering method and validate displaying text.","implementation#Implementation":"Open TextCell implementation on  github","interface-declaration#Interface declaration":"interface TextCell extends Cell {\n    type: 'text',\n    text: string,\n    placeholder?: string,\n    validator?: (text: string) => boolean,\n    renderer?: (text: string) => React.ReactNode\n}\nProperty name\tType\tProperty description\ttype\theader\tType of cell template\ttext\tstring\tText content of cell\tplaceholder?\tstring\tOptional, when text property is empty, display this value in placeholder input style\tvalidator?\t(text: string) => boolean\tOptional validation function, if undefined - returns true\trenderer?\t(text: string) => React.ReactNode\tOptional, gives oportunity to wrap text property into any ReactNode object"}},"/docs/4.0/4-cell-templates/9-TimeCell":{"title":"TimeCell","data":{"":"This template formats Date object and displays default browser time picker in edit mode.\nKeep in mind: time attribute that stores Date object instance will be stored with the date of January 1st, 1970 UTC.","implementation#Implementation":"Open TimeCell implementation on  github","interface-declaration#Interface declaration":"interface TimeCell extends Cell {\n    type: 'time';\n    time?: Date;\n    format?: Intl.DateTimeFormat;\n}\nProperty name\tType\tProperty description\ttype\tdate\tType of cell template\ttime?\tDate\tDate object, optional\tformat?\tIntl.DateTimeFormat\tFormats time, if undefined formats it according to current browser locale"}},"/docs/4.0/5-create-your-own-cell-template":{"title":"Create your own cell template","data":{"introduction#Introduction":"Creating a cell template is the best way to customize data visualization and behaviour in ReactGrid.\nYou can define your own one and then use it as other built-in cell types.In this example, we will explain how to make it.Let's imagine that you need to implement a brand new cell for displaying a country flag.Expected functionality:\nIn edit mode a cell allows you to type in text without any constraints\nWhen a cell is displayed, it should show a country flag based on the cell text\nLet's get started!","1-define-flag-cell-interface#1. Define flag cell interface":"For this tutorial we are going to use the previous project - handling changes.type attribute is necessary in any cell template, in our sample we will refer to this cell template by flag.\ntext attribute will store our ISO code and it's also necessary.\nexport interface FlagCell extends Cell {\n  type: \"flag\";\n  text: string;\n}","2-data-holders#2. Data holders":"At the beginning we should update columns and rows displayed by the grid.\nOur data is no longer a people array, but a flag indentified by its isoCode.\ninterface Flag {\n  isoCode: string;\n}\nconst getFlags = (): Flag[] => [\n  { isoCode: \"swe\" },\n  { isoCode: \"deu\" },\n  { isoCode: \"mex\" },\n  { isoCode: \"\" },\n];\nconst getColumns = (): Column[] => [{ columnId: \"flag\", width: 150 }];","3-creating-necessary-files#3. Creating necessary files":"Create new file named FlagCellTemplate.tsx, add the same imports as in the listing below and make flag-cell-style.css\nfile that will contain some CSS styles (don't forget to import it into your project's file).\n// FlagCellTemplate.tsx\nimport * as React from \"react\";\nimport {\n  CellTemplate,\n  Cell,\n  Compatible,\n  Uncertain,\n  UncertainCompatible,\n  isNavigationKey,\n  getCellProperty,\n  isAlphaNumericKey,\n  keyCodes,\n} from \"@silevis/reactgrid\";\nimport \"./flag-cell-style.css\";","4-creating-flagcelltemplate-class#4. Creating FlagCellTemplate class":"For all defined methods below it is necessary to display and interface the flag cell with internal ReactGrid model correctly.\ngetCompatibleCell as a parameter gets an incoming cell and returns a compatible cell (with text and value\nattribute required by Compatible type).\nIn more complex examples getCellProperty may throw an exception if the required cell field is undefined.\ngetCompatibleCell(uncertainCell: Uncertain<FlagCell>): Compatible<FlagCell> {\n    const text = getCellProperty(uncertainCell, 'text', 'string');\n    const value = parseFloat(text);\n    return { ...uncertainCell, text, value };\n}\nhandleKeyDown method handles keyDown event on this cell template. Here it just returns unchanged cell and enables\nedit mode when a user performed a click or pressed ENTER key.\nhandleKeyDown(\n    cell: Compatible<FlagCell>,\n    keyCode: number,\n    ctrl: boolean,\n    shift: boolean,\n    alt: boolean\n): { cell: Compatible<FlagCell>; enableEditMode: boolean } {\n    if (!ctrl && !alt && isAlphaNumericKey(keyCode))\n        return { cell, enableEditMode: true };\n    return {\n        cell,\n        enableEditMode: keyCode === keyCodes.POINTER || keyCode === keyCodes.ENTER\n    };\n}\nupdate - as we are not sure if an incoming cell has the same interface like FlagCell so we mark it\nas UncertainCompatible (the incoming cell has attributes provided by Compatible\nbut it can have other attributes like date from DateCell). In our case, we just copy cell and replace text value.\nupdate(cell: Compatible<FlagCell>, cellToMerge: UncertainCompatible<FlagCell>): Compatible<FlagCell> {\n    return this.getCompatibleCell({ ...cell, text: cellToMerge.text });\n}\nrender method returns the content of a cell. In edit mode we will display input element. The change which is made in the\ncell input is propagated outside ReactGrid by onCellChanged function.\nrender(\n    cell: Compatible<FlagCell>,\n    isInEditMode: boolean,\n    onCellChanged: (cell: Compatible<FlagCell>, commit: boolean) => void\n): React.ReactNode {\n  if (!isInEditMode) {\n    const flagISO = cell.text.toLowerCase(); // ISO 3166-1, 2/3 letters\n    const flagURL = `https://restcountries.eu/data/${flagISO}.svg`;\n    const alternativeURL = `https://upload.wikimedia.org/wikipedia/commons/0/04/Nuvola_unknown_flag.svg`;\n    return (\n      <div\n        className=\"rg-flag-wrapper\"\n        style={{ backgroundImage: `url(${flagURL}), url(${alternativeURL})` }}\n      />\n    );\n  }\n  return (\n    <input\n      ref={input => {\n        input && input.focus();\n      }}\n      defaultValue={cell.text}\n      onChange={e =>\n        onCellChanged(\n          this.getCompatibleCell({ ...cell, text: e.currentTarget.value }),\n          false\n        )\n      }\n      onCopy={e => e.stopPropagation()}\n      onCut={e => e.stopPropagation()}\n      onPaste={e => e.stopPropagation()}\n      onPointerDown={e => e.stopPropagation()}\n      onKeyDown={e => {\n      if (isAlphaNumericKey(e.keyCode) || isNavigationKey(e.keyCode))\n        e.stopPropagation();\n      }}\n    />\n  );\n}","5-styling#5. Styling":"To set a flag as the background covering the div element, we created CSS rg-flag-wrapper class.\nAll of the cells have a class name created based on the cell type attribute. In our case, the cell class name will be rg-flag-cell.\nAs rg-cell is a flex element we center its content with justify-content: center; attribute.\n.rg-flag-cell {\n  justify-content: center;\n}\n.rg-flag-wrapper {\n  width: 50%;\n  height: 80%;\n  background-size: cover;\n  border: 1px solid #cccccc;\n  background-position: center center;\n  background-repeat: no-repeat;\n}","6-updating-header-row-and-generating-flag-rows#6. Updating header row and generating flag rows":"Header row is still static, but displays only one cell.\nconst headerRow: Row = {\n  rowId: \"header\",\n  height: 40,\n  cells: [{ type: \"header\", text: \"Flags\" }],\n};\ngetRows function now process the flags array, and return array of Row<DefaultCellTypes | FlagCell>.\nThis record tells us that cells rows can be on one of DefaultCellTypes (build-in cell types) or brand new\ntemplate - FlagCell with type of flag.\nconst getRows = (flags: Flag[]): Row<DefaultCellTypes | FlagCell>[] => [\n  headerRow,\n  ...flags.map<Row<DefaultCellTypes | FlagCell>>((flag, idx) => ({\n    rowId: idx,\n    height: 60,\n    cells: [{ type: \"flag\", text: flag.isoCode }],\n  })),\n];","7-finishing#7. Finishing":"Go back to index.tsx file and add customCellTemplates property as shown below:\nfunction App() {\n  const [flags] = React.useState<Flag[]>(getFlags());\n  const rows = getRows(flags);\n  const columns = getColumns();\n  return (\n    <ReactGrid\n      rows={rows}\n      columns={columns}\n      customCellTemplates={{ flag: new FlagCellTemplate() }}\n    />\n  );\n}","result#Result":""}},"/docs/4.0/6-styling":{"title":"Styling","data":{"":"In this chapter, you will learn about simple and advanced ReactGrid components styling using Sass variables.\nBasic styling\nAdvanced styling\nSass variables"}},"/docs/4.0/6-styling/0-basic-styling":{"title":"Basic styling","data":{"introduction#Introduction":"For the correct display of the component it's required to import the basic styles contained directly inside\n@silevis/reactgrid package.","importing#Importing":"Styles are a necessary part of ReactGrid. For a correct display you have to import ReactGrid into your project.\n/* your-styles.css */\n@import '@silevis/reactgrid/styles.css';\nor if you use Sass preprocessor:\n/* your-styles.scss */\n@import '@silevis/reactgrid/styles.scss';\nYou can only import files that you need and then override variables yourself:\n/* your-styles.scss */\n@import './default-colors.scss';\n@import './default-sizing.scss';\n@import './cell-templates-default-colors.scss';\n@import './mapping.scss';\n@import './cell-templates.scss';\n@import './main.scss';"}},"/docs/4.0/6-styling/2-sass-variables":{"title":"Sass variables","data":{"":"ReactGrid uses an expanded set of variables you can override.","color-related-variables#Color related variables":"","color-variables#Color variables":"$primary-color: #3579f8 !default;\n$bg-color: #ffffff !default;\n$sticky-bg-color: #ffffff !default;\n$shadow-color: #000000 !default;\n$resize-line-color: #74b9ff !default;\n$resize-hint-bg-color: $resize-line-color !default;\n$resize-handle-gb-color: $primary-color !default;\n$cell-border-color: #111111 !default;\n$cell-editor-bg-color: #ffffff !default;\n$cell-editor-border-color: $primary-color !default;\n$fillhandle-action-border-color: #000000 !default;\n$partial-area-gb-color: $primary-color !default;\n$partial-area-border-color: $primary-color !default;\n$checkbox-checked: $primary-color !default;\n$checkbox-unchecked: #eeeeee !default;\n$checkbox-hover: #cccccc !default;\n$checkbox-mark: #ffffff !default;\n$dropdown-focused-item-bg-color: lighten(\n    $color: $primary-color,\n    $amount: 35,\n) !default;\n$dropdown-menu-bg-color: #ffffff !default;","shadow-variables#Shadow variables":"$shadow-blur-radius: 3px !default;\n$shadow-spread-radius: 1px !default;\n$shadow-length: 1px !default;\n$cell-editor-shadow: 1px 1px 6px !default;","context-menu-variables#Context menu variables":"$context-menu-shadow: 0px 0px 8px 2px !default;","opacity-variables#Opacity variables":"$opacity-80: 0.8 !default;\n$opacity-35: 0.35 !default;\n$opacity-20: 0.2 !default;\n$opacity-15: 0.15 !default;\n$opacity-10: 0.1 !default;\n$opacity-06: 0.06 !default;\n$opacity-01: 0.01 !default;","size-related-variables#Size related variables":"$cell-font-size:                        1em !default;\n$context-menu-font-size:                1em !default;\n$cell-padding:                          0 4px !default;\n$cell-focus-border-width:               2px !default;\n$celleditor-border-width:               2px !default;\n$celleditor-padding-top:                1px !default;\n$fill-handle-area:                      40px !default;\n$fill-handle-square:                    6.5px !default;\n$fill-handle-border-width:              1px !default;\n$resize-handle-area:                    11px !default;\n$resize-handle-line-width:              6px !default;\n$line-size:                             2px !default;\n$partial-area-border-width:             1px !default;\n$partial-area-selected-border-width:    1px !default;\n$checkbox-size:                         18px !default;\n$context-menu-option-padding:           8px 20px 8px 15px !default;","core-cell-templates-variables#Core cell templates variables":"$template-checkbox-size:    20px !default;\n$template-font-size:        1em !default;\n$template-bg-color:         transparent !default;\n$template-padding:          0 !default;\n$template-margin:           0 !default;\n$template-content-invalid:  rgb(255, 0, 0) !default;"}},"/docs/4.0/6-styling/1-advanced-styling":{"title":"Advanced styling","data":{"":"ReactGrid lets you style all key components using Sass variables.Before you use .scss files you have to install node-sass package:\nnpm install node-sass\nTo override default styles of ReactGrid you have to assign new values\n(available variables) and then import all  necessary .scss files.\nIf variable is not passed before getting imported core.scss it will not be modified.Here's an example of how to add custom focus style on your grid.\n// Your custom color\n$primary-color: #3579f8;\n@import '@silevis/reactgrid/styles.scss';\nSee full styling example below:\nIf you use multiple grids on the same page, make sure your grid styles are 'local'.\n// Independent ReactGrid classess\n#reactgrid-red {\n    $primary-color: red;\n    @import '@silevis/reactgrid/styles.scss';\n}\n#reactgrid-blue {\n    $primary-color: blue;\n    @import '@silevis/reactgrid/styles.scss';\n}\nWrap ReactGrid component into div element with class name:\n<div id=\"reactgrid-red\">\n    <ReactGrid {...props}/>\n</div>\n<div id=\"reactgrid-blue\">\n    <ReactGrid {...props}/>\n</div>"}},"/docs/4.0/7-api":{"title":"API Reference","data":{"":"ReactGrid API contains interfaces, types and functions exported from ReactGrid package to compose grids,\ndefine custom behaviour and data visualization.\nInterfaces\nTypes\nFunctions & Enums"}},"/docs/4.0/7-api/0-interfaces/1-reactgrid-props":{"title":"ReactGrid & ReactGridProps","data":{"":"ReactGrid component has two essential properties which you must pass in properties to render - columns and rows.","definition#Definition":"interface ReactGridProps {\n    readonly columns: Column[];\n    readonly rows: Row<Cell>[];\n    readonly customCellTemplates?: CellTemplates;\n    readonly focusLocation?: CellLocation;\n    readonly initialFocusLocation?: CellLocation;\n    readonly highlights?: Highlight[];\n    readonly stickyTopRows?: number;\n    readonly stickyBottomRows?: number;\n    readonly stickyLeftColumns?: number;\n    readonly stickyRightColumns?: number;\n    readonly enableFillHandle?: boolean;\n    readonly enableRangeSelection?: boolean;\n    readonly enableRowSelection?: boolean;\n    readonly enableColumnSelection?: boolean;\n    readonly labels?: TextLabels;\n    readonly enableFullWidthHeader?: boolean;\n    readonly enableGroupIdRender?: boolean;\n    readonly horizontalStickyBreakpoint?: number;\n    readonly verticalStickyBreakpoint?: number;\n    readonly disableVirtualScrolling?: number;\n    readonly onCellsChanged?: (cellChanges: CellChange[]) => void;\n    readonly onFocusLocationChanged?: (location: CellLocation) => void;\n    readonly onFocusLocationChanging?: (location: CellLocation) => boolean;\n    readonly onColumnResized?: (columnId: Id, width: number, selectedColIds: Id[]) => void;\n    readonly onRowsReordered?: (targetRowId: Id, rowIds: Id[], dropPosition: DropPosition) => void;\n    readonly onColumnsReordered?: (targetColumnId: Id, columnIds: Id[], dropPosition: DropPosition) => void;\n    readonly onContextMenu?: (selectedRowIds: Id[], selectedColIds: Id[], selectionMode: SelectionMode, menuOptions: MenuOption[], selectedRanges: Array<CellLocation[]>) => MenuOption[];\n    readonly canReorderColumns?: (targetColumnId: Id, columnIds: Id[], dropPosition: DropPosition) => boolean;\n    readonly canReorderRows?: (targetRowId: Id, rowIds: Id[], dropPosition: DropPosition) => boolean;\n}","properties#Properties":"Name\tType\tDescription\tcolumns\tColumns[]\tColumn's data\trows\tRows<Cell>[]\tRow's data\tcustomCellTemplates?\tCellTemplates\tSet of available custom cell templates\tfocusLocation?\tCellLocation\tFocus position (managed constantly by outer app)\tinitialFocusLocation?\tCellLocation\tInitial position of focus\thighlights?\tHighlight[]\tArray of highlight positions\tstickyTopRows?\tnumber\tAmount of rows which are sticky at the top\tstickyBottomRows?\tnumber\tAmount of rows which are sticky at the bottom\tstickyLeftColumns?\tnumber\tAmount of columns which are sticky on the left side\tstickyRightColumns?\tnumber\tAmount of columns which are sticky on the right side\tenableFillHandle?\tboolean\tSet true to enable cell fill feature (by default false)\tenableRangeSelection?\tboolean\tSet true to enable selection feature (by default false)\tenableRowSelection?\tboolean\tSet true to enable row selection feature (by default false)\tenableColumnSelection?\tboolean\tSet true to enable column selection feature (by default false)\tlabels?\tTextLabels\tObject that contains labels of texts used by ReactGrid\tenableFullWidthHeader?\tboolean\tSet true to enable full width header (by default false, feature is experimental)\tenableGroupIdRender?\tboolean\tSet true to enable groupId element rendering (by default false)\treadonly horizontalStickyBreakpoint?\tnumber\tHorizontal breakpoint in percents (%) of ReactGrid scrollable parent element width. Disables sticky when the sum of the sizes of sticky panes overflows given breakpoint value (by default 50)\tverticalStickyBreakpoint?\tnumber\tVertical breakpoint in percents (%) of ReactGrid scrollable parent element height. Disables sticky when the sum of the sizes of sticky panes overflows given breakpoint value (by default 50)\tdisableVirtualScrolling?\tboolean\tSet true to disable virtual scrolling (by default false)","callbacks#Callbacks":"Name\tType\tDescription\tonCellsChanged?\t(cellChanges: CellChange[]) => void;\tCalled when cell property (e.g. value) was changed\tonFocusLocationChanged?\t(location: CellLocation) => void;\tFocus position has been changed\tonFocusLocationChanging?\t(location: CellLocation) => boolean;\tCalled when trying to change focus location. Return false to prevent position changing\tonColumnResized?\t(columnId: Id, dropPosition: DropPosition) => void;\tCallback called when column resize action was ended\tonRowsReordered?\t(targetRowId: Id, rowIds: Id[], dropPosition: DropPosition) => void;\tCallback called when row reorder action was ended\tonColumnsReordered?\t(targetColumnId: Id, columnIds: Id[], dropPosition: DropPosition) => void;\tCallback called when column reorder action was ended\tonContextMenu?\t(selectedRowIds: Id[], selectedColIds: Id[], selectionMode: SelectionMode, menuOptions: MenuOption[], selectedRanges: Array<CellLocation[]>) => MenuOption[];\tCalled when user opens context menu inside grid, used to compose own menu options\tcanReorderColumns?\t(targetColumnId: Id, columnIds: Id[], dropPosition: DropPosition) => boolean;\tAllow or not to change specific columns order\tcanReorderRows?\t(targetRowId: Id, rowIds: Id[], dropPosition: DropPosition) => boolean;\tAllow or not to change specific rows order"}},"/docs/4.0/7-api/0-interfaces/3-column":{"title":"Column","data":{"":"This interface represents column in grid. Column interface contains only one necessary property: columnId.","definition#Definition":"interface Column {\n    readonly columnId: Id;\n    readonly width?: number;\n    readonly reorderable?: boolean;\n    readonly resizable?: boolean;\n}","properties#Properties":"Property name\tType\tProperty description\tcolumnId\tId\tUnique Id in all columns array\twidth?\tnumber\tWidth of each grid column (in default set to 150px)\treorderable?\tboolean\tAllow column to change its position in grid, default: false (row reorder implementation is on the developers side)\tresizable?\tboolean\tAllow column to change is width in grid, default: false (row resize implementation is on the developers side)"}},"/docs/4.0/7-api/0-interfaces/4-cell":{"title":"Cell","data":{"":"Cell interface is a base for built-in cell templates and your own, it has only one necessary property - type.","definition#Definition":"interface Cell {\n    type: string;\n    nonEditable?: boolean;\n    groupId?: Id;\n    style?: CellStyle;\n    className?: string;\n}","properties#Properties":"Properties\tType\tProperties description\ttype\tstring\tName of cell type, must be unique\tnonEditable?\tboolean\tMakes cell non editable - this property takes precedence over cell templating\tgroupId?\tId\tId of group to which this cell belongs to\tstyle?\tCellStyle\tAllowed style properties contained in CellStyle interface\tclassName?\tstring\tAdditional CSS classes\tcolspan?\tnumber\tSpecifies the number of columns a cell should span\trowspan?\tnumber\tSpecifies the number of rows a cell should span"}},"/docs/4.0/7-api/0-interfaces/6-cell-location":{"title":"CellLocation","data":{"":"CellLocation is an interface that describes position inside the grid.","definition#Definition":"interface CellLocation {\n    readonly rowId: Id;\n    readonly columnId: Id;\n}","properties#Properties":"Property name\tType\tProperty description\trowId\tId\tRow Id of cell location\tcolumnId\tId\tColumn Id of cell location"}},"/docs/4.0/7-api/0-interfaces/5-cell-template":{"title":"CellTemplate","data":{"":"CellTemplate is an interface used for communication between ReactGrid and a cell.\nAt this stage if you are still not familiar with cell marker interfaces, it might be helpful to read about them:\nCompatible\nUncertainCompatible\nUncertain","definition#Definition":"interface CellTemplate<TCell extends Cell = Cell> {\n    // Validate and convert to compatible cell type\n    getCompatibleCell(uncertainCell: Uncertain<TCell>): Compatible<TCell>;\n    // Returns true if the data in the cell is not replacable\n    // Default: _ => true\n    isFocusable?(cell: Compatible<TCell>): boolean;\n    // Update cell based on new props\n    // If not implemented, cell will be read-only\n    update?(cell: Compatible<TCell>, cellToMerge: UncertainCompatible<TCell>): Compatible<TCell>;\n    // The keyCode represents the key pressed on the keyboard, or 1 for a pointer event (double click).\n    // Returns the cell data either affected by the event or not.\n    // Default: cell => { cell, enableEditMode: false }\n    handleKeyDown?(cell: Compatible<TCell>, keyCode: number, ctrl: boolean, shift: boolean, alt: boolean): { cell: Compatible<TCell>; enableEditMode: boolean };\n    // Custom styles based on cell data applied to the cells div element\n    // Default: _ => cell.style | {}\n    getStyle?(cell: Compatible<TCell>, isInEditMode: boolean): CellStyle;\n    // Custom class names based on cell data applied to the cells div element\n    // Default: _ => cell.className | ''\n    getClassName?(cell: Compatible<TCell>, isInEditMode: boolean): string;\n    // Render the cell content\n    render(cell: Compatible<TCell>, isInEditMode: boolean, onCellChanged: (cell: Compatible<TCell>, commit: boolean) => void): React.ReactNode;\n}","properties#Properties":"Method\tReturns\tDescription\tgetCompatibleCell(uncertainCell: Uncertain<TCell>)\tCompatibleCell<TCell>\tValidates and converts into a compatible cell type\tisFocusable?(cell: Compatible<TCell>)\tboolean\tMarks a cell as focusable or not\tupdate?(cell: Compatible<TCell>, cellToMerge: UncertainCompatible<TCell>)\tCompatibleCell<TCell>\tUpdates cell based on new properties, if not implemented, a cell will be read-only\thandleKeyDown?(cell: Compatible<TCell>, keyCode: number, ctrl: boolean, shift: boolean, alt: boolean)\t{ cell: CompatibleCell<TCell>; enableEditMode: boolean }\tReturns the cell data either affected by an event or not.\tgetStyle?(cell: Compatible<TCell>, isInEditMode: boolean)\tCellStyle\tReturns custom styles based on cell data applied to the cells div element\tgetClassName?(cell: Compatible<TCell>, isInEditMode: boolean)\tstring\tReturns custom class names based on cell data applied to the cells div element\trender(cell: Compatible<TCell>, isInEditMode: boolean, onCellChanged: (cell: Compatible<TCell>, commit: boolean) => void)\tReact.ReactNode\tRenders cell content"}},"/docs/4.0/7-api/0-interfaces/6a-cell-templates":{"title":"CellTemplates","data":{"":"CellTemplates is an interface describes your custom cell templates as key-value object.\nKey of CellTemplates interface have to be equal to coresponding cell type field (with extends Cell interface).","definition#Definition":"interface CellTemplates {\n    [key: string]: CellTemplate;\n}","example#Example":"const myCellTemplates: CellTemplates = {\n    'flag': FlagCellTemplate,\n    'dropdownNumber': DropdownNumberCellTemplate,\n}\nreturn (\n    <ReactGrid\n      {...props}\n      customCellTemplates={myCellTemplates} // highlight-line\n    />\n);","properties#Properties":"Properties\tType\tProperties description\t[key: string]\tCellTemplate\tType of a cell template and its implementation"}},"/docs/4.0/7-api/0-interfaces/8-menuoption":{"title":"MenuOption","data":{"":"The context menu is part of the grid, each menu option must implement the interface below.","definition#Definition":"interface MenuOption {\n    id: string;\n    label: string;\n    handler: (selectedRowIds: Id[], selectedColIds: Id[], selectionMode: SelectionMode, selectedRanges: Array<CellLocation[]>) => void;\n}","properties#Properties":"Property name\tType\tProperty description\tid\tstring\tText that identifies each menu option\tlabel\tstring\tLabel displayed in menu\thandler\t(selectedRowIds: Id[], selectedColIds: Id[], selectionMode: SelectionMode, selectedRanges: Array<CellLocation[]>) => void`\tFunction that is called when option is clicked"}},"/docs/4.0/7-api/0-interfaces/9-highlight":{"title":"Highlight","data":{"":"Highlight is an element to mark any cell inside the grid with custom border color or CSS classHighlight (opposed to focus):\nit can be placed on any cell\nit must be managed by a developer unlike 'focus'","definition#Definition":"interface Highlight {\n    readonly rowId: Id;\n    readonly columnId: Id;\n    readonly borderColor?: string;\n    readonly className?: string;\n}","properties#Properties":"Property name\tType\tProperty description\trowId\tId\tRow Id of the cell to highlight\tcolumnId\tId\tColumn Id of the cell to highlight\tborderColor\tstring\tOptional border color\tclassName\tstring\tOptional CSS classname of the highlighted cell"}},"/docs/4.0/7-api/0-interfaces/7-cell-style":{"title":"CellStyle","data":{"":"CellStyle styles single cell and prevents passing unwanted CSS properties that could break down view rendering.\nThis interface uses also a BorderProps to style particular cells border edge.","definition#Definition":"interface CellStyle {\n    readonly color?: string;\n    readonly background?: string;\n    readonly overflow?: string;\n    readonly paddingLeft?: string;\n    readonly border?: {\n        readonly left?: BorderProps;\n        readonly top?: BorderProps;\n        readonly right?: BorderProps;\n        readonly bottom?: BorderProps;\n    }\n}\ninterface BorderProps {\n    readonly color?: string;\n    readonly style?: string;\n    readonly width?: string;\n}","properties#Properties":"CellStyle interface properties.\nProperty name\tType\tProperty description\tcolor?\tstring\tCSS color property\tbackground?\tstring\tCSS background property\toverflow?\tstring\tCSS overflow property\tpaddingLeft?\tstring\tCSS padding-left property\tborder?\t{ left?: BorderProps; top?: BorderProps; right?: BorderProps; bottom?: BorderProps; }\tObject that contains all cell's borders properties\t\nBorderProps interface properties. By default, cell has only right and bottom border, except cells on panes edges.\nIf you want to style cell border properly, it's important to declare all properties: color, style, width.\nProperty name\tType\tProperty description\tcolor?\tstring\tColor of border - e.g. #eee/red\tstyle?\tstring\tStyle of border - e.g. dotted/solid\twidth?\tstring\tWidth of border - e.g. 2px"}},"/docs/4.0/7-api/0-interfaces/90-textlabels":{"title":"TextLabels","data":{"":"TextLabels describes a set of text labels used by ReactGrids internal i18n module.\nEach text label has its own default value.","definition#Definition":"interface TextLabels {\n    legacyBrowserHeader?: string,\n    legacyBrowserText?: string,\n    copyLabel?: string,\n    cutLabel?: string,\n    pasteLabel?: string,\n    macOsContextMenuPasteAlert?: string,\n    otherBrowsersContextMenuPasteAlert?: string,\n    contextMenuPasteAlert?: string\n}","properties#Properties":"Property name\tType\tProperty description\tlegacyBrowserHeader?\tstring\tLabel of text header when browser isn't supported, by default: Please update to a modern browser.\tlegacyBrowserText?\tstring\tLabel of text paragraph when browser isn't supported, by default: Your current browser cannot run our content, please make sure you browser is fully updated or try adifferent browser. We highly recommend using the most recent release of Google Chrome, Microsoft Edge, Firefox, Safari, and Opera browser\tcopyLabel?\tstring\tLabel of copy action displayed inside context menu, by default: Copy\tcutLabel?\tstring\tLabel of cut action displayed inside context menu, by default: Cut\tpasteLabel?\tstring\tLabel of paste action displayed inside context menu, by default: Paste\tmacOsContextMenuPasteAlert?\tstring\tAlert label in use (e.g. MacOS) if access to the clipboard is denied, by default: Use ⌘ + c for copy, ⌘ + x for cut and ⌘ + v for paste.\totherBrowsersContextMenuPasteAlert?\tstring\tAlert label in use (e.g. Firefox) if access to the clipboard is denied, by default:  Use ctrl + c for copy, ctrl + x for cut and ctrl + v for paste.\tcontextMenuPasteAlert?\tstring\tAlert label in use (e.g. Firefox) if access to the clipboard is denied, by default: This action is not supported in this browser."}},"/docs/4.0/7-api/0-interfaces":{"title":"Interfaces","data":{"":"ReactGrid API provides following interfaces:","interfaces#Interfaces":"ReactGridProps\nRow\nColumn\nCell\nCellTemplates\nCellTemplate\nCellChange\nCellLocation\nCellStyle\nMenuOption\nHighlight\nTextLabels"}},"/docs/4.0/7-api/1-types/1-compatible-cell":{"title":"Compatible","data":{"":"CompatibleCell is an extended and exchangeable cell (compatible with different types).","definition#Definition":"type Compatible<TCell extends Cell> = TCell & {\n    text: string;\n    value: number;\n}","properties#Properties":"Property name\tType\tProperty description\ttext\tstring\tText value of a cell\tvalue\tnumber\tNumeric value of a cell, if there is no numeric value representation use NaN"}},"/docs/4.0/7-api/1-types/2-cell-change":{"title":"CellChange","data":{"":"CellChange type is used by onCellsChanged callback in ReactGrid component. It represents\nmutually exclusive changes to a single cell.CellTypes utility type extracts all possible cell types based on Cell interface.Generic Change interface represents a particullar change on single cell on concrete cell template.","basic-usage-cases#Basic usage cases":"const handleChangesOnDefaults = (changes: CellChange[]) => { // evaluates as `Change<TextCell> | Change<Datecell> | ...`\n  changes.forEach(change => {\n    if (change.type === 'checkbox') {\n      console.log(change.newCell.checked);\n      console.log(change.previousCell.checked);\n    }\n  });\n};\nconst handleChangesOnDefaultsAndFlagCell = (changes: CellChange<DefaultCellTypes | FlagCell>[]) => { // evaluates as `Change<TextCell> | Change<Datecell> | ... | Change<FlagCell>`\n  changes.forEach(change => {\n    if (change.type === 'flag') {\n      // `FlagCell` specyfic fields are now available\n      console.log(change.newCell.text);\n      console.log(change.previousCell.text);\n    }\n  });\n};\nconst handleChangesOnlyOnDateCell = (changes: CellChange<DateCell>[]) => { // evaluates as `Change<DateCell>`\n  changes.forEach(change => {\n    // only available type is now `date`\n    if (change.type === 'date') {\n      console.log(change.newCell.date);\n      console.log(change.previousCell.date);\n    }\n  });\n};","definition#Definition":"declare type CellChange<TCell extends Cell = DefaultCellTypes & Cell> = TCell extends Cell ? {\n    /** Row's `Id` where the change ocurred */\n    readonly rowId: Id;\n    /** Column's `Id` where the change ocurred */\n    readonly columnId: Id;\n    /** Extracted cell type of `TCell` (e.g. `text`, `chevron` and so on) */\n    readonly type: TCell['type'];\n    /** Previous content of the cell */\n    readonly previousCell: TCell;\n    /** New content of the cell */\n    readonly newCell: TCell;\n} : never;\nTCell is type that extends common Cell type.\nIt can be one of default cell types or one of yours.\nRead more about creating custom cell templates.","properties#Properties":"Property name\tType\tProperty description\trowId\tId\tRow Id where the change ocurred\tcolumnId\tId\tColumn Id where the change ocurred\ttype\tCellTypes<TCell>\tExtracted cell type of TCell e.g. text, chevron\tpreviousCell\tTCell extends Cell = Cell\tPrevious content of the cell\tnewCell\tTCell extends Cell = Cell\tNew content of the cell"}},"/docs/4.0/7-api/1-types/3-uncertain-compatible-cell":{"title":"UncertainCompatible","data":{"":"UncertainCompatible is a cell type that is compatible with other cell types\nthat can be instances of various cell types (e.g. DataCell and TimeCell).","definition#Definition":"type UncertainCompatible<TCell extends Cell> = Uncertain<TCell> & {\n    text: string;\n    value: number;\n}"}},"/docs/4.0/7-api/1-types/2-uncertain-cell":{"title":"Uncertain","data":{"":"Uncertain is a cell type that every field of TCell is optional.\nCell of this type will have only one essential field provided by Cell interface - type.","definition#Definition":"type Uncertain<TCell extends Cell> = Partial<TCell> & Cell;"}},"/docs/4.0/7-api/1-types/4-id":{"title":"Id","data":{"":"Id is a common type to identify many objects in grid e.g.:\nHighlight,\nCellLocation,\nCellChange,\nColumn,\nRow\nId can be a number or string.","definition#Definition":"type Id = number | string;"}},"/docs/4.0/7-api/1-types/5-drop-position":{"title":"DropPosition","data":{"":"Indicates where row/column was dropped. Used by ReactGridProps callbacks.","definition#Definition":"type DropPosition = 'before' | 'on' | 'after';"}},"/docs/5.0":{"title":"5.0","data":{"":"ReactGrid lets you create custom data grids inside your ReactJS applications, which look and feel like spreadsheets.","caveats#Caveats":"a) If you notice sticky incorrect behavior, when you try to pin them to HTML <body> tag, add this line to index.html file in your project.\nIt should be helpful in many cases and different mobile devices.\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=0.86, maximum-scale=5.0, minimum-scale=0.86\">","supported-browsers#Supported browsers":"Desktop Browsers\nMobile Browsers"}},"/docs/4.0/7-api/1-types/6-default-cells":{"title":"DefaultCellTypes","data":{"":"ReactGrid API contains a union of basic cells usually used for consuming changes and\nmarking cells array inside the data row.","definition#Definition":"type DefaultCellTypes = CheckboxCell | DateCell | EmailCell | ChevronCell | HeaderCell | NumberCell | TextCell | TimeCell;"}},"/docs/4.0/7-api/1-types":{"title":"Types","data":{"":"ReactGrid API provides following types:\nCompatible\nCellChange\nUncertain\nUncertainCompatible\nId\nDropPosition\nDefaultCellTypes\nSelectionMode"}},"/docs/4.0/7-api/1-types/7-selection-mode":{"title":"SelectionMode","data":{"":"ReactGrid API contains three types of values which can be used in selection.\nIt is row, column or range. It's used for marking currect selection mode while\nexecuting exact event.","definition#Definition":"type SelectionMode = 'row' | 'column' | 'range';"}},"/docs/4.0/7-api/2-functions":{"title":"Functions & Enums","data":{"keycodes#Keycodes":"Keycode related functions are commonly used by every cell template and they uses the unicode value of pressed keyboard key\n(exacly like KeyboardEvent.keyCode).\nisAlphaNumericKey(keyCode: number): boolean\nUsed in creating custom cell templates. Checks if keycode is alphanumeric.\ninNumericKey(keyCode: number): boolean\nUsed in creating custom cell templates. Checks if keycode is between 0 and 9 (also on numpad).\nisNumpadNumericKey(keyCode: number): boolean\nUsed in creating custom cell templates. Checks if keycode is between 0 and 9 on numpad.\nisAllowedOnNumberTypingKey(keyCode: number): boolean\nUsed in creating custom cell templates. Checks if keycode is allowed while typing\nnumbers (for chars like comma, dash, period).\nisNavigationKey(keyCode: number): boolean\nUsed in creating custom cell templates. Checks if keycode is allowed for navigation\n(arrows, end, home, backspace, delete keys).\ngetCharFromKeyCode(keyCode: number, isShiftKey: boolean = false): boolean\nConverts key code into char including the Shift key.","helpers#Helpers":"getCellProperty = <TCell extends Cell, TKey extends keyof TCell>(\n    uncertainCell: Uncertain<TCell>,\n    propName: TKey,\n    expectedType: 'string' | 'number' | 'boolean' | 'undefined' | 'function' | 'object' | string\n)\nReturns cell property value. Used to create a compatible cell.","enums#Enums":"keyCodes enum contains a set of key codes + POINTER = 1 to mark a pointer event (ReactGrid addon).\nUsed in cell templates."}},"/docs/5.0/1-getting-started":{"title":"Getting started","data":{"introduction-to-version-5#Introduction to version 5":"In this guide, we're going to build a very simple React App, which will make use of ReactGrid.","npm-install#NPM Install":"npm i @silevis/reactgrid\nUnlike previous versions, there's no longer a need to import the CSS file separately.","integrate-reactgrid-into-the-app#Integrate ReactGrid into the App":"To integrate ReactGrid into your application, configure the grid using rows, columns, and cells. However, if you provide only cells with specified rowIndex and colIndex, the rows and columns will be automatically generated. If you want to define specific row heights, column widths or row and column reordering, you should pass them explicitly to the ReactGrid component. Below is a detailed breakdown of how to set this up, including an example configuration file.","configure-reactgrid-inside-your-application#Configure ReactGrid inside your application":"Let's generate rows, columns, and cells using the prepared data:","summary#Summary":"You should now have a basic understanding of what ReactGrid is and how it can be used."}},"/docs/5.0/2-implementing-core-features/10-copy-cut-paste":{"title":"Copy Cut Paste","data":{"copy-cut-paste#Copy Cut Paste":"Support for cut, copy, and paste is enabled by default. You can disable these features by passing disableCut, disableCopy, and disablePaste props to the ReactGrid component, respectively. If you'd like to implement your own logic, the following props are available:\nonCut?: (event: React.ClipboardEvent<HTMLDivElement>, cellsRange: NumericalRange, cellsLookup: CellsLookup) => boolean;\nonCopy?: (event: React.ClipboardEvent<HTMLDivElement>, cellsRange: NumericalRange, cellsLookup: CellsLookup) => boolean;\nonPaste?: (event: React.ClipboardEvent<HTMLDivElement>, cellsRange: NumericalRange, cellsLookup: CellsLookup) => boolean;","parameters#Parameters":"Name\tType\tDescription\tevent\tReact.ClipboardEvent<HTMLDivElement>\tThe clipboard event triggered by the cut, copy, or paste action.\tcellsRange\tNumericalRange\tThe range of cells involved in the cut, copy, or paste action.\tcellsLookup\tCellsLookup\tA map object that provides callbacks to get and set cell values. Each key is a string combining row and column indices, and the value is an object with rowIndex, colIndex, onStringValueRequested (callback to get the cell value), and onStringValueReceived (callback to set the cell value).","return-value#Return Value":"The return value of these handlers determines whether the custom logic should override the default cut, copy, or paste behavior.\nReturn Value\tType\tDescription\ttrue\tboolean\tPrevent the default behavior.\tfalse\tboolean\tDefault behavior should proceed without being prevented. It is used in case you want to perform additional actions before allowing the default behavior.","live-example#Live example":"Below is an example with overridden logic for cut, copy, and paste. Additionally, handlePaste utilizes the setSelectedArea method from the useReactGridAPI hook to highlight the new cell area after pasting the data."}},"/docs/5.0/2-implementing-core-features/3-column-resizing":{"title":"Column resizing","data":{"column-resizing#Column Resizing":"To enable column resizing, simply define your columns within the your component and set the onResizeColumn prop on the ReactGrid component.\n/**\n  * Callback function that is triggered when a column is resized.\n  * \n  * @param width - The new width of the column.\n  * @param columnIdx - An array of column indexes that were resized. There may be more than one index in the case of spanned headers.\n  * @returns void\n*/\nonResizeColumn?: (width: number, columnIdx: number[]) => void;","live-example#Live example":""}},"/docs/5.0/2-implementing-core-features/2-handling-changes":{"title":"Handling data changes","data":{"handling-data-changes#Handling data changes":"By default, ReactGrid provides two built-in editable cell templates: TextCell and NumberCell:\n// TextCell\ninterface TextCellProps {\n  text: string;\n  onTextChanged: (newText: string) => void;\n  style?: React.CSSProperties;\n}\n// NumberCell\ninterface NumberCellProps {\n  value: number;\n  onValueChanged: (newValue: number) => void;\n  validator?: (value: number) => boolean;\n  errorMessage?: string;\n  hideZero?: boolean;\n  format?: Intl.NumberFormat;\n  style?: React.CSSProperties;\n}\nNote: You can easily create custom cell templates to suit your needs.Each cell template includes a handler to manage data changes. For the TextCell, this is the onTextChanged handler, and for the NumberCell, it’s onValueChanged. These handlers allow you to update your source data and re-render ReactGrid with the new values.\nconst peopleArr = [\n  {\n    _id: \"66d61077035753f369ddbb16\",\n    name: \"Jordan Rodriquez\",\n    age: 30,\n    email: \"jordanrodriquez@cincyr.com\",\n    company: \"Zaggles\",\n    position: 1,\n  },\n  {\n    _id: \"66d61077794e7949ab167fd5\",\n    email: \"allysonrios@satiance.com\",\n    name: \"Allyson Rios\",\n    age: 30,\n    company: \"Zoxy\",\n    position: 2,\n  },\n  {\n    _id: \"66d61077dd754e88981ae434\",\n    name: \"Pickett Lucas\",\n    age: 25,\n    email: \"pickettlucas@zoxy.com\",\n    company: \"Techade\",\n    position: 3,\n  },\n  {\n    _id: \"66d61077115e2f8748c334d9\",\n    name: \"Louella David\",\n    age: 37,\n    email: \"louelladavid@techade.com\",\n    company: \"Ginkogene\",\n    position: 4,\n  },\n  {\n    _id: \"66d61077540d53374b427e4b\",\n    name: \"Tricia Greene\",\n    age: 27,\n    email: \"triciagreene@ginkogene.com\",\n    company: \"Naxdis\",\n    position: 5,\n  },\n];\nconst ReactGridExample = () => {\n  const [people, setPeople] = useState(peopleArr);\n  const updatePerson = (id, key, newValue) => {\n    setPeople((prev) => {\n      return prev.map((p) => (p._id !== id ? p : { ...p, [key]: newValue }));\n    });\n  };\n  const cells = [\n    {\n      rowIndex: 0,\n      colIndex: 0,\n      Template: TextCell;\n      props?: {\n        text: people[0].name,\n        onTextChanged: (newText) => {\n          updatePerson(people[0]._id, \"name\", newText);\n        },\n      }\n    },\n    //...\n  ];\n  return <ReactGrid cells={cells} />;\n};"}},"/docs/5.0/2-implementing-core-features/1-initial-focus-location":{"title":"Initial focus location","data":{"initial-focus-location#Initial focus location":"The focused location isn't set up by default. You can enable it by setting the initialFocusLocation property in the ReactGrid component.Example:\n<ReactGrid\n  cells={cells}\n  rows={rows}\n  columns={columns}\n  initialFocusLocation={{ rowIndex: 2, colIndex: 1 }}\n/>\nNote: The focused cell is entirely controlled by the browser's focus mechanism, which means it can easily be set programmatically. The recommended approach for doing this is by using the setFocusedCell method from the useReactGridAPI hook.Alternatively, you can directly invoke the .focus() method. Example:\ndocument.querySelector(\"rgHiddenFocusTarget rgFocusRowIdx-3 rgFocusColIdx-3\").focus();"}},"/docs/5.0/2-implementing-core-features/5-fill-handle":{"title":"Fill handle","data":{"about-fill-handling-in-reactgrid#About fill handling in ReactGrid":"The fill handle is enabled by default in ReactGrid. You can disable it by passing the disableFillHandle prop to the ReactGrid component. If you want to implement custom logic for the fill handle behavior, you can use the onFillHandle prop.\nonFillHandle?: (selectedArea: NumericalRange, fillRange: NumericalRange, cellsLookup: CellsLookup) => boolean;","parameters#Parameters":"Name\tType\tDescription\tselectedArea\tNumericalRange\tThe range of cells that were initially selected.\tfillRange\tNumericalRange\tThe range of cells that the fill handle is dragged over.\tcellsLookup\tCellsLookup\tA map object that provides callbacks to get and set cell values. Each key is a string combining row and column indices, and the value is an object with rowIndex, colIndex, onStringValueRequested (callback to get the cell value), and onStringValueReceived (callback to set the cell value).","return-value#Return Value":"The return value of these handlers determines whether the custom logic should override the default fill handle behavior.\nReturn Value\tType\tDescription\ttrue\tboolean\tPrevent the default fill handle behavior.\tfalse\tboolean\tDefault behavior should proceed without being prevented. It is used in case you want to perform additional actions before allowing the default fill handle behavior.","live-example#Live example":"Below is an example of logic that overrides the fill handle:"}},"/docs/5.0/2-implementing-core-features/4-sticky":{"title":"Sticky rows and columns","data":{"sticky-cells#Sticky cells":"ReactGrid allows you to stick chosen rows and columns at the top or left side and additionally on the right and at the bottom\nof the ReactGrid viewport. Sticky rows or columns will be visible at all times, no matter what the scroll position is.Sticky rows and columns can be enabled by adding dedicated ReactGrid component properties:\nstickyTopRows\nstickyBottomRows\nstickyLeftColumns\nstickyRightColumns\nAll of these properties are numeric and determine the number of columns or rows sticky next to the grid's edges.","how-to-make-columns-and-rows-sticky#How to make columns and rows sticky?":"Use the properties mentioned in the introduction to set the number of sticky ranges at each edge.","live-example#Live example":""}},"/docs/5.0/2-implementing-core-features/6-styled-ranges":{"title":"Styles ranges","data":{"styled-ranges#Styled ranges":"In addition to directly passing styles to individual cells, you can also use the styleRanges prop, which allows you to customize a specific area of cells in a table.\nstyledRanges?: StyledRange[];\ntype StyledRange = {\n  styles: React.CSSProperties;\n  range: Range;\n};\ntype Range = {\n  start: {\n    rowIndex: number;\n    columnIndex: number;\n  };\n  end: {\n    rowIndex: number;\n    columnIndex: number;\n  };\n};","live-example#Live example":""}},"/docs/5.0/2-implementing-core-features/7-keyboard-shortcuts":{"title":"Keyboard shortcuts","data":{"about-keyboard-events#About keyboard events":"ReactGrid allows you to interact with the grid using keyboard shortcuts in a way known from other spreadsheet-like apps.Note: You can customize keyboard shortcuts by overriding the default behavior of ReactGrid.","keyboard-shortcuts#Keyboard shortcuts":"Shortcut\tAction\t↑\tMoves cell focus one cell up (if is focusable)\t↓\tMoves cell focus one cell down (if is focusable)\t←\tMoves cell focus to the left (if is focusable)\t→\tMoves cell focus to the right (if is focusable)\tEnter\tOpens cell editor if cell is focused or moves focus down inside range selection\tDelete or Backspace\tWipe selected range or only focused location\tTab\tMoves focus to the right if single cell is selected or moves focus to the right inside range selection\tHome\tMoves focus to the first column\tEnd\tMoves focus to the last column\tPageUp\tMoves focus up by one page (visible number of rows)\tPageDown\tMoves focus down by one page (visible number of rows)\tEscape\tAborts cell edition without changing it\tCtrl + Space\tExpands selection in vertical direction (only on Apple devices)\tCtrl  + Shift + Home or  ⌘ + Shift + Home\tSelects all cells above currect selection\tCtrl + Shift + End or  ⌘ + Shift +  End\tSelects all cells below currect selection\t⌘ + A or Ctrl + A\tSelects all cells\t⌘ + Home or Ctrl + Home\tSelects top left cell\t⌘ + End or Ctrl + End\tSelects bottom right cell\tCtrl + End\tSelect whole column on Windows\tShift + Enter\tCloses cell editor if it is opened and moves focus cell above last edited cell\tShift + ↑\tSelects one cell above\tShift + ↓\tSelects one cell below\tShift + ←\tSelects one cell on the left\tShift + →\tSelects one cell on the right\tShift + Tab\tMoves focus to the left if single cell is selected or moves focus to the left inside range selection\tShift + Enter\tMoves focus one cell above if single cell is selected or moves focus up inside range selection\tShift + Space\tExpands selection in horizontal direction (from top to bottom)\tShift + Home\tExpands selection to the first column\tShift + End\tExpands selection to the last column\tShift + PageUp\tIncrease or decrease selection by single page\tShift + PageDown\tIncrease or decrease selection by single page"}},"/docs/5.0/2-implementing-core-features/9-column-and-row-reordering":{"title":"Column and row reordering","data":{"column-and-row-reordering#Column and row reordering":"To enable row or column reordering in ReactGrid, the following props need to be passed to the component:\nFor row reordering:\nenableRowSelectionOnFirstColumn?: boolean;\nonRowReorder?: (selectedRowIndexes: number[], destinationRowIdx: number) => void;\nFor column reordering:\nenableColumnSelectionOnFirstRow?: boolean;\nonColumnReorder?: (selectedColIndexes: number[], destinationColIdx: number) => void;","live-example#Live example":""}},"/docs/5.0/2-implementing-core-features/8-cell-span":{"title":"Cell span","data":{"spanned-cells-in-reactgrid#Spanned cells in ReactGrid":"You can specify the number of rows or columns a cell spans by using the rowSpan and colSpan properties when creating cells for ReactGrid.","live-example#Live example":""}},"/docs/5.0/3-cell-templates":{"title":"Cell templates","data":{"builtin-cell-templates#Builtin cell templates":"TextCell\nNumberCell\nNonEditableCell"}},"/docs/5.0/3-cell-templates/1-text-cell":{"title":"TextCell","data":{"textcell#TextCell":"The TextCell template is used to display and manipulate text values within a cell.","implementation#Implementation":"Open TextCell implementation on GitHub","interface-declaration#Interface declaration":"interface TextCellProps {\n  text: string;\n  onTextChanged: (newText: string) => void;\n  style?: React.CSSProperties;\n}\nProperty name\tType\tDescription\ttext\tstring\tThe text content of the cell.\tonTextChanged\t(newText: string) => void\tCallback function that is called when the user commits text changes.\tstyle?\tReact.CSSProperties\tCSS properties to apply to the cell."}},"/docs/5.0/3-cell-templates/3-non-editable-cell":{"title":"NonEditableCell","data":{"noneditablecell#NonEditableCell":"The NonEditableCell template is used to display non-editable text values within a cell.","implementation#Implementation":"Open NonEditableCell implementation implementation on GitHub","interface-declaration#Interface declaration":"interface NonEditableCellProps {\n  value?: string;\n  style?: React.CSSProperties;\n}\nProperty name\tType\tDescription\tvalue?\tstring\tThe text value of the cell.\tstyle?\tReact.CSSProperties\tCSS properties to apply to the cell."}},"/docs/5.0/3-cell-templates/2-number-cell":{"title":"NumberCell","data":{"numbercell#NumberCell":"The NumberCell template is used to display and manipulate numeric values within a cell.","implementation#Implementation":"Open NumberCell implementation on GitHub","interface-declaration#Interface declaration":"interface NumberCellProps {\n  value: number;\n  onValueChanged: (newValue: number) => void;\n  validator?: (value: number) => boolean;\n  errorMessage?: string;\n  hideZero?: boolean;\n  allowSeparators?: boolean;\n  format?: Intl.NumberFormat;\n  style?: React.CSSProperties;\n}\nProperty name\tType\tDescription\tvalue\tnumber\tThe numeric value of the cell.\tonValueChanged\t(newValue: number) => void\tCallback function that is called when the user commits text changes.\tvalidator?\t(value: number) => boolean\tFunction to validate the value.\terrorMessage?\tstring\tError message to display when validation fails.\thideZero?\tboolean\tFlag to hide the zero value.\tallowSeparators?\tboolean\tFlag to allow or disallow the use of separators in the cell.\tformat?\tIntl.NumberFormat\tNumber format to apply to the value.\tstyle?\tReact.CSSProperties\tCSS properties to apply to the cell."}},"/docs/5.0/4-create-your-own-cell-template":{"title":"Create your own cell template","data":{"custom-cell-templates#Custom cell templates":"Creating a cell template is the best way to customize data visualization and behaviour in ReactGrid.\nYou can define your own one and then use it as other built-in cell types. For example if you want use custom text cell you can copy default TextCell component and modify it as you want.The key to implementing a custom cell is integrating it with the CellWrapper, which handles communication between the cell and ReactGrid.\n<CellWrapper\n  onStringValueRequested={() => value?.toString() || \"\"}\n  onStringValueReceived={() => {\n    // Logic to update the cell value\n  }}\n>\n  {/* Render cell content here */}\n</CellWrapper>\nonStringValueRequested and onStringValueReceived are required props for the CellWrapper component. These props handle retrieving and updating cell values through the cellsLookup.\ntype CellWrapperProps = React.HTMLAttributes<HTMLDivElement> & {\n  onStringValueRequested: () => string;\n  onStringValueReceived: (v: string) => void;\n  children?: React.ReactNode;\n};","example#Example":"Let's create a custom DateCell template:","live-example#Live example":""}},"/docs/5.0/5-styling":{"title":"Styling","data":{"styling-reactgrid#Styling ReactGrid":"In version 5, ReactGrid introduces the RGTheme interface, allowing you to apply a theme directly to the grid. You can also customize styles by passing them through individual cell properties or using standard CSS.","live-example#Live example":""}},"/docs/5.0/6-api/0-interfaces/2-reactgrid-api":{"title":"ReactGridAPI","data":{"reactgridapi#ReactGridAPI":"The ReactGridAPI interface is related to the useReactGridAPI hook and provides various methods to interact with the grid, such as selecting areas, focusing cells, and retrieving grid data.","definition#Definition":"interface ReactGridAPI {\n  setSelectedArea: (range: NumericalRange) => void;\n  setFocusedCell: ({ rowIndex, colIndex }: IndexedLocation) => void;\n  setSelectedColumns: (startColIdx: number, endColIdx: number) => void;\n  setSelectedRows: (startRowIdx: number, endRowIdx: number) => void;\n  getFocusedCell: () => FocusedCell | null;\n  getCellByIndexes: (rowIndex: number, colIndex: number) => Cell | null;\n  getCellOrSpanMemberByIndexes: (rowIndex: number, colIndex: number) => Cell | SpanMember | null;\n  getPaneRanges: () => Record<PaneName, NumericalRange>;\n  getCellsLookup: () => CellsLookup;\n  getSelectedArea: () => NumericalRange | null;\n  getColumns: () => Column[];\n  getRows: () => Row[];\n}"}},"/docs/5.0/6-api/0-interfaces/1-reactgrid-props":{"title":"ReactGridProps","data":{"reactgridprops#ReactGridProps":"The ReactGridProps interface defines the properties and callbacks that can be used to configure the ReactGrid component. This interface allows to customize the grid's appearance, behavior, and interactions.","definition#Definition":"interface ReactGridProps {\n  id?: string;\n  styles?: NestedStylesPartial<RGTheme>;\n  styledRanges?: StyledRange[];\n  rows?: Row[];\n  columns?: Column[];\n  cells: Cell[];\n  onAreaSelected?: (selectedArea: NumericalRange) => void;\n  onCellFocused?: (cellLocation: IndexedLocation) => void;\n  stickyTopRows?: number;\n  stickyRightColumns?: number;\n  stickyBottomRows?: number;\n  stickyLeftColumns?: number;\n  enableColumnSelectionOnFirstRow?: boolean;\n  enableRowSelectionOnFirstColumn?: boolean;\n  behaviors?: Partial<Record<BehaviorId, Behavior>>;\n  initialFocusLocation?: IndexedLocation;\n  initialSelectedRange?: Range;\n  disableCut?: boolean;\n  disableCopy?: boolean;\n  disablePaste?: boolean;\n  disableFillHandle?: boolean;\n  onFocusLocationChanging?: ({ location }: { location: IndexedLocation }) => boolean;\n  onFocusLocationChanged?: ({ location }: { location: IndexedLocation }) => void;\n  onFillHandle?: (selectedArea: NumericalRange, fillRange: NumericalRange, cellsLookup: CellsLookup) => boolean;\n  onCut?: (event: React.ClipboardEvent<HTMLDivElement>, cellsRange: NumericalRange, cellsLookup: CellsLookup) => boolean;\n  onCopy?: (event: React.ClipboardEvent<HTMLDivElement>, cellsRange: NumericalRange, cellsLookup: CellsLookup) => boolean;\n  onPaste?: (event: React.ClipboardEvent<HTMLDivElement>, cellsRange: NumericalRange, cellsLookup: CellsLookup) => boolean;\n  onColumnReorder?: (selectedColIndexes: number[], destinationColIdx: number) => void;\n  onRowReorder?: (selectedRowIndexes: number[], destinationRowIdx: number) => void;\n  onResizeColumn?: (width: number, columnIdx: number[]) => void;\n}","properties#Properties":"Name\tType\tDescription\tid\tstring\tOptional unique identifier for the grid. It should be passed if the useReactGridAPI hook is to be used.\tstyles\tNestedStylesPartial<RGTheme>\tOptional styles for the grid.\tstyledRanges\tStyledRange[]\tOptional styled ranges within the grid.\trows\tRow[]\tOptional array of rows.\tcolumns\tColumn[]\tOptional array of columns.\tcells\tCell[]\tArray of cells.\tstickyTopRows\tnumber\tNumber of sticky rows at the top.\tstickyRightColumns\tnumber\tNumber of sticky columns on the right.\tstickyBottomRows\tnumber\tNumber of sticky rows at the bottom.\tstickyLeftColumns\tnumber\tNumber of sticky columns on the left.\tenableColumnSelectionOnFirstRow\tboolean\tEnable column selection on the first row.\tenableRowSelectionOnFirstColumn\tboolean\tEnable row selection on the first column.\tmoveRightOnEnter\tboolean\tMoves the focus to the right cell when the Enter key is pressed. By default, it is set to false.\tbehaviors\tPartial<Record<BehaviorId, Behavior>>\tOptional property that allows to override default ReactGrid behaviors.\tinitialFocusLocation\tIndexedLocation\tInitial focus location in the grid.\tinitialSelectedRange\tRange\tInitial selected range in the grid.\tdisableCut\tboolean\tDisables the cut functionality in the grid.\tdisableCopy\tboolean\tDisables the copy functionality in the grid.\tdisablePaste\tboolean\tDisables the paste functionality in the grid.\tdisableFillHandle\tboolean\tDisables the fill handle functionality in the grid.","callbacks#Callbacks":"Name\tType\tDescription\tonAreaSelected\t(selectedArea: NumericalRange) => void\tCallback when an area is selected.\tonCellFocused\t(cellLocation: IndexedLocation) => void\tCallback when a cell is focused.\tonFocusLocationChanging\t({ location }: { location: IndexedLocation }) => boolean\tCallback before focus location changes.\tonFocusLocationChanged\t({ location }: { location: IndexedLocation }) => void\tCallback after focus location changes.\tonFillHandle\t(selectedArea: NumericalRange, fillRange: NumericalRange, cellsLookup: CellsLookup) => boolean\tCallback for fill handle action.\tonCut\t(event: React.ClipboardEvent<HTMLDivElement>, cellsRange: NumericalRange, cellsLookup: CellsLookup) => boolean\tCallback for cut action.\tonCopy\t(event: React.ClipboardEvent<HTMLDivElement>, cellsRange: NumericalRange, cellsLookup: CellsLookup) => boolean\tCallback for copy action.\tonPaste\t(event: React.ClipboardEvent<HTMLDivElement>, cellsRange: NumericalRange, cellsLookup: CellsLookup) => boolean\tCallback for paste action.\tonColumnReorder\t(selectedColIndexes: number[], destinationColIdx: number) => void\tCallback for column reorder action.\tonRowReorder\t(selectedRowIndexes: number[], destinationRowIdx: number) => void\tCallback for row reorder action.\tonResizeColumn\t(width: number, columnIdx: number[]) => void\tCallback for column resize action."}},"/docs/5.0/6-api/1-types/2-column":{"title":"Column","data":{"definition#Definition":"type Column = {\n  colIndex: number;\n  width: string | number;\n  minWidth?: string | number;\n  resizable?: boolean;\n  reorderable?: boolean;\n};","properties#Properties":"Name\tType\tDescription\tcolIndex\tnumber\tThe index of the column.\twidth\tstring | number\tThe width of the column.\tminWidth\tstring | number\tThe minimum width of the column.\tresizable\tboolean (optional)\tIndicates if the column is resizable.\treorderable\tboolean (optional)\tIndicates if the column can be reordered."}},"/docs/5.0/6-api/1-types/1-row":{"title":"Row","data":{"definition#Definition":"type Row = {\n  rowIndex: number;\n  height: string | number;\n  reorderable?: boolean;\n};","properties#Properties":"Name\tType\tDescription\trowIndex\tnumber\tThe index of the row.\theight\tstring | number\tThe height of the row.\treorderable\tboolean (optional)\tIndicates if the row can be reordered."}},"/docs/5.0/6-api/1-types/3-cell":{"title":"Cell","data":{"definition#Definition":"type Cell = {\n  rowIndex: number;\n  colIndex: number;\n  Template: React.ComponentType<any>;\n  props?: React.ComponentPropsWithRef<Cell[\"Template\"]>;\n  rowSpan?: number;\n  colSpan?: number;\n  isFocusable?: boolean;\n  isSelectable?: boolean;\n};","properties#Properties":"Name\tType\tDescription\trowIndex\tnumber\tUser-defined row index, must exist in the rows array.\tcolIndex\tnumber\tUser-defined column index, must exist in the columns array.\tTemplate\tReact.ComponentType<any>\tCell's template, typically the name of the React component. Should start with an uppercase letter.\tprops\tReact.ComponentPropsWithRef<Cell[\"Template\"]>\tProps passed to the cell's template. It's an object inherited from the Template prop.\trowSpan\tnumber (optional)\tRepresents how many rows the cell should occupy.\tcolSpan\tnumber (optional)\tRepresents how many columns the cell should occupy.\tisFocusable\tboolean (optional)\tMarks a cell as focusable or not.\tisSelectable\tboolean (optional)\tMarks a cell as selectable or not."}},"/docs/5.0/6-api/1-types/4-cells-lookup":{"title":"CellsLookup","data":{"introduction#Introduction":"The CellsLookup is designed to work specifically with string values, allowing you to retrieve and update cells data. The primary use case for CellsLookup is within operations like cut, copy, paste, and fill, where you need to access or modify cell content based on row and column indices. This type functions as a mapping of cell coordinates, identified by row and column indices, to callback functions. These callbacks— onStringValueRequested and onStringValueReceived—enable interaction with the grid's cell values, helping facilitate tasks such as data editing, copying, and filling, all while ensuring the values remain in a string format for consistency and simplicity.","definition#Definition":"type CellsLookup<\n  RowIdxType extends number = number,\n  ColIdxType extends number = number\n> = Map<`${RowIdxType} ${ColIdxType}`, CellsLookupCallbacks>;\ntype CellsLookupCallbacks = {\n  rowIndex: number;\n  colIndex: number;\n  onStringValueRequested: () => string;\n  onStringValueReceived: (v: string) => void;\n};","properties#Properties":"Name\tType\tDescription\trowIndex\tnumber\tThe index of the row.\tcolIndex\tnumber\tThe index of the column.\tonStringValueRequested\t() => string\tCallback to get the cell value.\tonStringValueReceived\t(v: string) => void\tCallback to set the cell value."}},"/docs/5.0/6-api/1-types/7-styled-range":{"title":"StyledRange","data":{"definition#Definition":"type StyledRange = {\n  styles: React.CSSProperties;\n  range: Range;\n};\ntype Range = {\n  start: {\n    rowIndex: number;\n    columnIndex: number;\n  };\n  end: {\n    rowIndex: number;\n    columnIndex: number;\n  };\n};","properties#Properties":"Name\tType\tDescription\tstyles\tReact.CSSProperties\tThe CSS properties to apply to the range.\trange\tRange\tThe range of cells to which the styles apply.\trange.start.rowIndex\tnumber\tThe starting row index of the range.\trange.start.columnIndex\tnumber\tThe starting column index of the range.\trange.end.rowIndex\tnumber\tThe ending row index of the range.\trange.end.columnIndex\tnumber\tThe ending column index of the range."}},"/docs/5.0/6-api/1-types/5-cell-context":{"title":"CellContext","data":{"definition#Definition":"type CellContextType = {\n  realRowIndex: number;\n  realColumnIndex: number;\n  rowSpan?: number;\n  colSpan?: number;\n  containerStyle: React.CSSProperties;\n  isFocused: boolean;\n};","properties#Properties":"Name\tType\tDescription\trealRowIndex\tnumber\tNumerical cell's row index representation in relation to the whole grid (including sticky rows).\trealColumnIndex\tnumber\tNumerical cell's column index representation in relation to the whole grid (including sticky columns).\trowSpan\tnumber (optional)\tRepresents how many rows the cell should occupy.\tcolSpan\tnumber (optional)\tRepresents how many columns the cell should occupy.\tcontainerStyle\tReact.CSSProperties\tInternal: provides the cell container's style.\tisFocused\tboolean\tIndicates if the cell is focused."}},"/docs/5.0/6-api/1-types/6-numerical-range":{"title":"NumericalRange","data":{"definition#Definition":"type NumericalRange = {\n  startRowIdx: number;\n  endRowIdx: number;\n  startColIdx: number;\n  endColIdx: number;\n};","properties#Properties":"Name\tType\tDescription\tstartRowIdx\tnumber\tThe starting row index of the range.\tendRowIdx\tnumber\tThe ending row index of the range.\tstartColIdx\tnumber\tThe starting column index of the range.\tendColIdx\tnumber\tThe ending column index of the range."}},"/docs/5.0/6-api/1-types/8-behavior":{"title":"Behavior","data":{"definition#Definition":"type Behavior = {\n  id: BehaviorId;\n  handlePointerDown?: PointerEventHandler;\n  handlePointerEnter?: PointerEventHandler;\n  handlePointerMove?: PointerEventHandler;\n  handlePointerLeave?: PointerEventHandler;\n  handlePointerUp?: PointerEventHandler;\n  handlePointerHold?: PointerHoldEventHandler;\n  handlePointerDownTouch?: PointerEventHandler;\n  handlePointerMoveTouch?: PointerEventHandler;\n  handlePointerEnterTouch?: PointerEventHandler;\n  handlePointerUpTouch?: PointerEventHandler;\n  handlePointerHoldTouch?: PointerHoldEventHandler;\n  handleFocus?: FocusEventHandler;\n  handleDoubleClick?: MouseEventHandler;\n  handleKeyDown?: KeyboardEventHandler;\n  handleKeyUp?: KeyboardEventHandler;\n  handleCompositionStart?: CompositionEventHandler;\n  handleCompositionUpdate?: CompositionEventHandler;\n  handleCompositionEnd?: CompositionEventHandler;\n  handleCut?: ClipboardEventHandler;\n  handleCopy?: ClipboardEventHandler;\n  handlePaste?: ClipboardEventHandler;\n  handleContextMenu?: MouseEventHandler;\n};","properties#Properties":"Name\tType\tDescription\tid\tBehaviorId\t\"Default\" | \"CellSelection\" | \"ColumnReorder\" | \"RowReorder\" | \"ResizeColumn\" | \"FillHandle\"\thandlePointerDown\tPointerEventHandler\tHandler for pointer down events.\thandlePointerEnter\tPointerEventHandler\tHandler for pointer enter events.\thandlePointerMove\tPointerEventHandler\tHandler for pointer move events.\thandlePointerLeave\tPointerEventHandler\tHandler for pointer leave events.\thandlePointerUp\tPointerEventHandler\tHandler for pointer up events.\thandlePointerHold\tPointerHoldEventHandler\tHandler for pointer hold events.\thandlePointerDownTouch\tPointerEventHandler\tHandler for pointer down touch events.\thandlePointerMoveTouch\tPointerEventHandler\tHandler for pointer move touch events.\thandlePointerEnterTouch\tPointerEventHandler\tHandler for pointer enter touch events.\thandlePointerUpTouch\tPointerEventHandler\tHandler for pointer up touch events.\thandlePointerHoldTouch\tPointerHoldEventHandler\tHandler for pointer hold touch events.\thandleFocus\tFocusEventHandler\tHandler for focus events.\thandleDoubleClick\tMouseEventHandler\tHandler for double click events.\thandleKeyDown\tKeyboardEventHandler\tHandler for key down events.\thandleKeyUp\tKeyboardEventHandler\tHandler for key up events.\thandleCompositionStart\tCompositionEventHandler\tHandler for composition start events.\thandleCompositionUpdate\tCompositionEventHandler\tHandler for composition update events.\thandleCompositionEnd\tCompositionEventHandler\tHandler for composition end events.\thandleCut\tClipboardEventHandler\tHandler for cut events.\thandleCopy\tClipboardEventHandler\tHandler for copy events.\thandlePaste\tClipboardEventHandler\tHandler for paste events.\thandleContextMenu\tMouseEventHandler\tHandler for context menu events."}},"/docs/5.0/6-api/2-hooks/1-usereactgridapi":{"title":"useReactGridAPI","data":{"introduction#Introduction":"The useReactGridAPI hook provides a set of methods to interact with the ReactGrid component. It allows you to set and get various states of the grid, such as the selected area, focused cell, and selected rows or columns. This hook is essential for managing the grid's state programmatically.","definition#Definition":"function useReactGridAPI(id: string): ReactGridAPI | undefined {\n  return useReactGridStoreApi(id, (store: ReactGridStore) => {\n    return {\n      // Setters\n      setSelectedArea: (range: NumericalRange) => {\n        return store.setSelectedArea(range);\n      },\n      setFocusedCell: ({ rowIndex, colIndex }: IndexedLocation) => {\n        const cell = store.getCellByIndexes(rowIndex, colIndex);\n        if (devEnvironment && !cell) {\n          console.warn(`Cell with rowIdx \"${rowIndex}\" and colIdx \"${colIndex}\" does not exist.`);\n        }\n        return store.setFocusedLocation(rowIndex, colIndex);\n      },\n      setSelectedColumns: (startColIdx: number, endColIdx: number) => {\n        return store.setSelectedColumns(startColIdx, endColIdx);\n      },\n      setSelectedRows: (startRowIdx: number, endRowIdx: number) => {\n        return store.setSelectedRows(startRowIdx, endRowIdx);\n      },\n      // Getters\n      getFocusedCell: store.getFocusedCell,\n      getCellByIndexes: store.getCellByIndexes,\n      getCellOrSpanMemberByIndexes: store.getCellOrSpanMemberByIndexes,\n      getPaneRanges: store.getPaneRanges,\n      getCellsLookup: store.getCellsLookup,\n      getSelectedArea: store.getSelectedArea,\n      getRows: () => store.rows,\n      getColumns: () => store.columns,\n    };\n  });\n}","api-methods#API Methods":"Name\tType\tDescription\tsetSelectedArea\t(range: NumericalRange) => void\tSet the selected area in the ReactGrid.\tsetFocusedCell\t({ rowIndex, colIndex }: IndexedLocation) => void\tSet the focused cell in the ReactGrid.\tsetSelectedColumns\t(startColIdx: number, endColIdx: number) => void\tSet the selected columns in the ReactGrid.\tsetSelectedRows\t(startRowIdx: number, endRowIdx: number) => void\tSet the selected rows in the ReactGrid.\tgetFocusedCell\t() => IndexedLocation | undefined\tGet the currently focused cell in the ReactGrid.\tgetCellByIndexes\t(rowIndex: number, colIndex: number) => Cell | undefined\tGet the cell at the specified indexes in the ReactGrid.\tgetCellOrSpanMemberByIndexes\t(rowIndex: number, colIndex: number) => Cell | SpanMember | undefined\tGet the cell or span member at the specified indexes in the ReactGrid.\tgetPaneRanges\t() => PaneRange[]\tGet the pane ranges in the ReactGrid.\tgetCellsLookup\t() => CellsLookup\tGet the cells lookup in the ReactGrid.\tgetSelectedArea\t() => NumericalRange | undefined\tGet the selected area in the ReactGrid.\tgetRows\tColumn[]\tGet the rows in the ReactGrid.\tgetColumns\tRow[]\tGet the columns in the ReactGrid."}},"/docs/5.0/6-api/3-functions/1-isvalidkey":{"title":"isValidKey","data":{"isvalidkey-function#isValidKey Function":"The isValidKey function checks if a keyboard event is triggered by a valid key without any specified invalid keys or modifier keys. This function is particularly useful when you want to prevent entering edit mode for a cell on certain keys.\ntype isValidKey = (event: React.KeyboardEvent, invalidKeys?: string[]) => boolean;","parameters#Parameters":"Parameter\tType\tDescription\tevent\tReact.KeyboardEvent\tThe keyboard event to check.\tinvalidKeys\tstring[] (optional)\tAn optional array of additional keys that should be considered invalid.","returns#Returns":"Type\tDescription\tboolean\ttrue if the event is triggered by a valid key without any specified invalid keys or modifier keys, false otherwise."}},"/docs/3.0/7-api/0-interfaces/2-row":{"title":"Row","data":{"":"Row interface contains two necessary properties: rowId and cells. It contains essential information about the grid row.\ncells field allows you to declare an array of objects that extends Cell[] base interface.","usage#Usage":"const rows: Row[] = [\n  {\n    rowId: 0,\n    cells: [\n      { type: \"text\", text: 'John' },\n      { type: \"text\", text: \"Doe\" },\n    ]\n  }\n]\nIf you want to use your custom cell templates in code, the correct way of doing so is: Row<DefaultCellTypes | MyCustomCell>.\ninterface FlagCell extends Cell {\n  type: 'flag';\n  text: string;\n}\nexport const rows: Row<DefaultCellTypes | FlagCell>[] = [ // union of all  available cells\n  {\n    rowId: 0,\n    cells: [\n      { type: \"text\", text: 'John' },\n      { type: \"text\", text: \"Doe\" },\n      // `flag type is now allowed\n      { type: 'flag', text: 'ger' }, //highlight-line\n    ]\n  }\n]","definition#Definition":"export interface Row<TCell extends Cell = DefaultCellTypes> {\n  readonly rowId: Id;\n  readonly cells: Cell[] | TCell[];\n  readonly height?: number;\n  readonly reorderable?: boolean;\n};","properties#Properties":"Property name\tType\tProperty description\trowId\tId\tUnique Id in all rows array\tcells\tCell[]  TCell extends Cell[]\tArray of Cell objects.\theight?\tnumber\tHeight of each grid row (in default set to 25px)\treorderable?\tboolean\tProperty that allows row to change is position in grid, default: false (row reorder implementation is on the developer's side)"}},"/docs/3.1/7-api/0-interfaces/2-row":{"title":"Row","data":{"":"Row interface contains two necessary properties: rowId and cells. It contains essential information about the grid row.\ncells field allows you to declare an array of objects that extends Cell[] base interface.","usage#Usage":"const rows: Row[] = [\n  {\n    rowId: 0,\n    cells: [\n      { type: \"text\", text: 'John' },\n      { type: \"text\", text: \"Doe\" },\n    ]\n  }\n]\nIf you want to use your custom cell templates in code, the correct way of doing so is: Row<DefaultCellTypes | MyCustomCell>.\ninterface FlagCell extends Cell {\n  type: 'flag';\n  text: string;\n}\nexport const rows: Row<DefaultCellTypes | FlagCell>[] = [ // union of all  available cells\n  {\n    rowId: 0,\n    cells: [\n      { type: \"text\", text: 'John' },\n      { type: \"text\", text: \"Doe\" },\n      // `flag type is now allowed\n      { type: 'flag', text: 'ger' }, //highlight-line\n    ]\n  }\n]","definition#Definition":"export interface Row<TCell extends Cell = DefaultCellTypes> {\n  readonly rowId: Id;\n  readonly cells: TCell[];\n  readonly height?: number;\n  readonly reorderable?: boolean;\n};","properties#Properties":"Property name\tType\tProperty description\trowId\tId\tUnique Id in all rows array\tcells\tCell[]  TCell extends Cell[]\tArray of Cell objects.\theight?\tnumber\tHeight of each grid row (in default set to 25px)\treorderable?\tboolean\tProperty that allows row to change is position in grid, default: false (row reorder implementation is on the developer's side)"}},"/docs/4.0/7-api/0-interfaces/2-row":{"title":"Row","data":{"":"Row interface contains two necessary properties: rowId and cells. It contains essential information about the grid row.\ncells field allows you to declare an array of objects that extends Cell[] base interface.","usage#Usage":"const rows: Row[] = [\n  {\n    rowId: 0,\n    cells: [\n      { type: \"text\", text: 'John' },\n      { type: \"text\", text: \"Doe\" },\n    ]\n  }\n]\nIf you want to use your custom cell templates in code, the correct way of doing so is: Row<DefaultCellTypes | MyCustomCell>.\ninterface FlagCell extends Cell {\n  type: 'flag';\n  text: string;\n}\nexport const rows: Row<DefaultCellTypes | FlagCell>[] = [ // union of all  available cells\n  {\n    rowId: 0,\n    cells: [\n      { type: \"text\", text: 'John' },\n      { type: \"text\", text: \"Doe\" },\n      // `flag type is now allowed\n      { type: 'flag', text: 'ger' }, //highlight-line\n    ]\n  }\n]","definition#Definition":"export interface Row<TCell extends Cell = DefaultCellTypes> {\n  readonly rowId: Id;\n  readonly cells: TCell[];\n  readonly height?: number;\n  readonly reorderable?: boolean;\n};","properties#Properties":"Property name\tType\tProperty description\trowId\tId\tUnique Id in all rows array\tcells\tCell[]  TCell extends Cell[]\tArray of Cell objects.\theight?\tnumber\tHeight of each grid row (in default set to 25px)\treorderable?\tboolean\tProperty that allows row to change is position in grid, default: false (row reorder implementation is on the developer's side)"}}}