---
posttype: "docs"
title: Create your own cell template
metaTitle: "Create your own cell template"
metaDescription: "ReactGrid docs"
---

#### Custom cell templates

Creating a cell template is the best way to customize data visualization and behaviour in ReactGrid.
You can define your own one and then use it as other built-in cell types. For example if you want use custom text cell you can copy default [TextCell](/docs/5.0/3-cell-templates/1-text-cell) component and modify it as you want.

The key to implementing a custom cell is integrating it with the `CellWrapper`, which handles communication between the cell and ReactGrid.

```tsx
<CellWrapper 
  onStringValueRequested={() => value?.toString() || ""} 
  onStringValueReceived={() => {
    // cell value update logic
  }} 
>
  {/* cell content */}
</CellWrapper>
```

Both `onStringValueRequested` and `onStringValueReceived` are required props for `CellWrapper` and are used to get and set the cell value using [CellsLookup](/docs/5.0/6-api/1-types/4-cells-lookup) inside handlers like cut, copy, paste, or fill.

```tsx
type CellWrapperProps = React.HTMLAttributes<HTMLDivElement> & {
  onStringValueRequested: () => string;
  onStringValueReceived: (v: string) => void;
  children?: React.ReactNode;
};
```

#### Example
Let's create a custom `DateCell` template:


### Live example

import LiveCode from "@/nextra/components/LiveCode.tsx";
import React, { useState, useRef } from "react";
import {
  ReactGrid,
  NumberCell,
  TextCell,
  NonEditableCell,
  Row,
  Cell,
  CellWrapper,
  useCellContext,
} from "@silevis/reactgrid";
import moment from "moment";

<LiveCode
  scope={{
    useState,
    useRef,
    ReactGrid,
    NumberCell,
    TextCell,
    NonEditableCell,
    Row,
    Cell,
    CellWrapper, 
    useCellContext,
    moment,
    peopleArr: [
      {
        _id: "66d61077035753f369ddbb16",
        name: "Jordan Rodriquez",
        birth: moment("1991-01-01"),
        email: "jordanrodriquez@cincyr.com",
        company: "Zaggles",
        position: 1,
      },
      {
        _id: "66d61077794e7949ab167fd5",
        email: "allysonrios@satiance.com",
        name: "Allyson Rios",
        birth: moment("1991-01-01"),
        company: "Zoxy",
        position: 2,
      },
      {
        _id: "66d61077dd754e88981ae434",
        name: "Pickett Lucas",
        birth: moment("1996-01-01"),
        email: "pickettlucas@zoxy.com",
        company: "Techade",
        position: 3,
      },
      {
        _id: "66d61077115e2f8748c334d9",
        name: "Louella David",
        birth: moment("1984-01-01"),
        email: "louelladavid@techade.com",
        company: "Ginkogene",
        position: 4,
      },
      {
        _id: "66d61077540d53374b427e4b",
        name: "Tricia Greene",
        birth: moment("1994-01-01"),
        email: "triciagreene@ginkogene.com",
        company: "Naxdis",
        position: 5,
      },
    ],
  }}
  code={`
interface Person {
  _id: string;
  name: string;
  birth: Moment;
  email: string;
  company: string;
  position: number;
}

const inputStyle: CSSProperties = {
  boxSizing: "border-box",
  textAlign: "center",
  width: "100%",
  height: "100%",
  background: "transparent",
  border: "none",
  padding: 0,
  outline: "none",
  color: "inherit",
  fontSize: "inherit",
  fontFamily: "inherit",
  // TODO
  WebkitCalendarPickerIndicator: {
   backgroundColor: "yellow",
  },
};

interface DateCellProps {
  value: Moment;
  onValueChanged: (data: Moment) => void;
}

const DateCell: FC<DateCellProps> = ({ value, onValueChanged }) => {
  const ctx = useCellContext();
  const targetInputRef = useRef<HTMLInputElement>(null);
  const [isEditMode, setEditMode] = useState(false);

  let formattedDate: string | undefined;

  if (!value) {
    formattedDate = "";
  } else {
    formattedDate = value.format("DD-MM-YYYY");
  }

  return (
    <CellWrapper
      onStringValueRequested={() => value.toDate().toDateString()}
      onStringValueReceived={(v) => onValueChanged?.(moment(v))}
      style={{ padding: ".2rem", textAlign: "center", outline: "none" }}
      onDoubleClick={() => {
        ctx.isFocused && setEditMode(true);
      }}
      onKeyDown={(e) => {
        if (!isEditMode && e.key === "Enter") {
          e.stopPropagation();
          setEditMode(true);
        }
      }}
    >
      {isEditMode ? (
        <input
          type="date"
          style={inputStyle}
          defaultValue={value.format("YYYY-MM-DD")}
          onBlur={(e) => {
            const changedDate = e.currentTarget.value;
            changedDate && onValueChanged(moment(e.currentTarget.value));
            setEditMode(false);
          }}
          onPointerDown={(e) => e.stopPropagation()}
          onKeyDown={(e) => {
            if (e.key === "Escape") {
              setEditMode(false);
            } else if (e.key === "Enter") {
              onValueChanged(moment(e.currentTarget.value));
              setEditMode(false);
            }
          }}
          autoFocus
          ref={targetInputRef}
        />
      ) : (
        formattedDate
      )}
    </CellWrapper>
  );
};

const CustomCellExample = () => {
  const [people, setPeople] = useState<Person>(peopleArr);

  const columnDefs = Object.keys(peopleArr[0]).reduce((acc, peopleKey, idx) => {
    if (["_id", "position"].includes(peopleKey)) return acc;
    const cellTemplate = peopleKey === "birth" ? DateCell : TextCell;
    return [...acc, { title: peopleKey, width: 250, cellTemplate }];
  }, []);

  const updatePerson = (id, key, newValue) => {
    setPeople((prev) => {
      return prev.map((p) => (p._id !== id ? p : { ...p, [key]: newValue }));
    });
  };

  const gridRows = Array.from({ length: people.length + 1 }, (_, i) => ({
    rowIndex: i,
    height: 40,
  }));

  const gridColumns = columnDefs.map((col, index) => ({
    colIndex: index,
    width: col.width,
  }));

  const cells = [];

  gridRows.forEach((row, rowIndex) => {
    const personRowIndex = row.rowIndex;

    if (rowIndex === 0) {
      columnDefs.forEach((col, colIndex) => {
        cells.push({
          rowIndex,
          colIndex,
          Template: NonEditableCell,
          props: {
            value: col.title,
            style: {
              backgroundColor: "#55bc71",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              fontWeight: "bold",
            },
          },
          isSelectable: false,
        });
      });
    } else {
      const personCells = columnDefs.map((col) => {
        const dateCellProps = {
          onValueChanged: (newValue) => {
            updatePerson(people[personRowIndex - 1]._id, col.title, newValue);
          },
          value: people[personRowIndex - 1][col.title.toLowerCase()],
        };

        const textCellProps = {
          text: people[personRowIndex - 1][col.title.toLowerCase()],
          onTextChanged: (newText) => {
            updatePerson(people[personRowIndex - 1]._id, col.title, newText);
          },
        };

        return {
          Template: col.cellTemplate,
          props: col.title === "birth" ? dateCellProps : textCellProps,
        };
      });

      columnDefs.forEach((_, colIndex) => {
        cells.push({
          rowIndex,
          colIndex,
          ...personCells[colIndex],
        });
      });
    }
  });

  return (
    <ReactGrid
      rows={gridRows}
      columns={gridColumns}
      cells={cells}
    />
  );
};

render(<CustomCellExample />, document.getElementById("root"));
`}
/>
