---
posttype: "docs"
title: Fill handle
metaTitle: "Fill handle"
metaDescription: "ReactGrid docs"
---

#### About fill handling in ReactGrid

The fill handle is enabled by default in ReactGrid. You can disable it by passing the `disableFillHandle` prop to the `ReactGrid` component. If you want to implement custom logic for the fill handle behavior, you can use the `onFillHandle` prop.

```ts
onFillHandle?: (selectedArea: NumericalRange, fillRange: NumericalRange, cellsLookup: CellsLookup) => boolean;
```

#### Parameters

Name         | Type                                      | Description |
-------------|-------------------------------------------|-------------|
`selectedArea`      | `NumericalRange`    | The range of cells that were initially selected. |
`fillRange` | `NumericalRange`                          | The range of cells that the fill handle is dragged over. |
`cellsLookup`| `CellsLookup`                             | A map object that provides callbacks to get and set cell values. Each key is a string combining row and column indices, and the value is an object with `rowIndex`, `colIndex`, `onStringValueRequested` (callback to get the cell value), and `onStringValueReceived` (callback to set the cell value). |


#### Return Value

The return value of these handlers determines whether the custom logic should override the default fill handle behavior.

| Return Value | Type      | Description                                                                                           |
|--------------|-----------|-------------------------------------------------------------------------------------------------------|
| `true`       | `boolean` | Custom logic should override the default fill handle behavior.                                         |
| `false`      | `boolean` | Default behavior should proceed without being overridden by custom logic. This allows for additional actions to be performed before allowing the default behavior. |


---

### Live example

Below is an example of logic that overrides the fill handle:

---

import LiveCode from "@/nextra/components/LiveCode.tsx";
import React, { useState } from "react";
import {
  ReactGrid,
  NumberCell,
  TextCell,
  NonEditableCell,
  Row,
  Cell,
} from "@silevis/reactgrid";


<LiveCode
  scope={{
    useState,
    ReactGrid,
    NumberCell,
    TextCell,
    NonEditableCell,
    Row,
    Cell,
    peopleArr: [
      {
        _id: "66d61077035753f369ddbb16",
        name: "Jordan Rodriquez",
        age: 30,
        email: "jordanrodriquez@cincyr.com",
        company: "Zaggles",
        position: 1,
      },
      {
        _id: "66d61077794e7949ab167fd5",
        email: "allysonrios@satiance.com",
        name: "Allyson Rios",
        age: 30,
        company: "Zoxy",
        position: 2,
      },
      {
        _id: "66d61077dd754e88981ae434",
        name: "Pickett Lucas",
        age: 25,
        email: "pickettlucas@zoxy.com",
        company: "Techade",
        position: 3,
      },
      {
        _id: "66d61077115e2f8748c334d9",
        name: "Louella David",
        age: 37,
        email: "louelladavid@techade.com",
        company: "Ginkogene",
        position: 4,
      },
      {
        _id: "66d61077540d53374b427e4b",
        name: "Tricia Greene",
        age: 27,
        email: "triciagreene@ginkogene.com",
        company: "Naxdis",
        position: 5,
      },
    ]
  }}
  code={`
interface Person {
  _id: string;
  name: string;
  birth: Moment;
  email: string;
  company: string;
  position: number;
}

interface ColumnDef {
  title: string;
  width: number;
  cellTemplate: React.ComponentType<any>;
}

const handleFill = (
  selectedArea: NumericalRange,
  fillRange: NumericalRange,
  cellsLookup: CellsLookup
): boolean => {
  // Check if the fill handle is being dragged upwards
  const isFillingUpwards = fillRange.startRowIdx < selectedArea.startRowIdx;
  // Calculate the number of rows and columns in the selected area
  const relativeRowSize = selectedArea.endRowIdx - selectedArea.startRowIdx;
  const relativeColSize = selectedArea.endColIdx - selectedArea.startColIdx;

  // Iterate over the rows and columns in the fill range
  for (let i = fillRange.startRowIdx; i < fillRange.endRowIdx; i++) {
    for (let j = fillRange.startColIdx; j < fillRange.endColIdx; j++) {
      const currentCellCallbacks = cellsLookup.get(i + " " + j);

      if (!currentCellCallbacks) continue;

      // Skip cells of type 'header'
      if (i === 0) continue;

      // Calculate the relative row and column indices within the selected area
      const relativeRowIdx = isFillingUpwards
        ? (selectedArea.endRowIdx - i - 1) % relativeRowSize
        : (i - fillRange.startRowIdx) % relativeRowSize;
      const relativeColIdx = (j - fillRange.startColIdx) % relativeColSize;

      // Get the value from the cell in the selected area that corresponds to the relative row and column indices
      const sourceCellCallbacks = cellsLookup.get(
          (selectedArea.startRowIdx + relativeRowIdx) + " " + (selectedArea.startColIdx + relativeColIdx)
      );

      if (sourceCellCallbacks) {
        const newValue = sourceCellCallbacks.onStringValueRequsted();
        currentCellCallbacks.onStringValueReceived(newValue);
      }
    }
  }

  // Override the default fill handle behavior
  return true;
};


const FillHandleExample = () => {
  const [people, setPeople] = useState<Person[]>(peopleArr);

  const columnDefs = Object.keys(peopleArr[0]).reduce((acc, peopleKey, idx) => {
    if (["_id", "position"].includes(peopleKey)) return acc;
    const cellTemplate = peopleKey === "age" ? NumberCell : TextCell;
    return [...acc, { title: peopleKey, width: 100 * idx, cellTemplate }];
  }, []);

  const updatePerson = (id, key, newValue) => {
    setPeople((prev) => {
      return prev.map((p) => (p._id !== id ? p : { ...p, [key]: newValue }));
    });
  };

  const gridRows = Array.from({ length: people.length + 1 }, (_, i) => ({
    rowIndex: i,
    height: 40,
  }));

  const gridColumns = columnDefs.map((col, index) => ({
    colIndex: index,
    width: col.width,
  }));

  const cells = [];

  gridRows.forEach((row, rowIndex) => {
    const personRowIndex = row.rowIndex;

    if (rowIndex === 0) {
      columnDefs.forEach((col, colIndex) => {
        cells.push({
          rowIndex,
          colIndex,
          Template: NonEditableCell,
          props: {
            value: col.title,
            style: {
              backgroundColor: "#55bc71",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              fontWeight: "bold",
            },
          },
          isSelectable: false,
        });
      });
    } else {
      const personCells = columnDefs.map((col) => {
        const numberCellProps = {
          onValueChanged: (newValue) => {
            updatePerson(people[personRowIndex - 1]._id, col.title, newValue);
          },
          value: people[personRowIndex - 1][col.title.toLowerCase()],
          allowSeparators: false,
        };

        const textCellProps = {
          text: people[personRowIndex - 1][col.title.toLowerCase()],
          onTextChanged: (newText) => {
            updatePerson(people[personRowIndex - 1]._id, col.title, newText);
          },
        };

        return {
          Template: col.cellTemplate,
          props: col.title === "age" ? numberCellProps : textCellProps,
        };
      });

      columnDefs.forEach((_, colIndex) => {
        cells.push({
          rowIndex,
          colIndex,
          ...personCells[colIndex],
        });
      });
    }
  });

  return (
    <ReactGrid
      onFillHandle={handleFill}
      rows={gridRows}
      columns={gridColumns}
      cells={cells}
    />
  );
};

render(<FillHandleExample />, document.getElementById("root"));
  `}
/>